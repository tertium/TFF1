\section{Translations} \label{sec:trans}

We describe three translations from TFF1 to different fragments of TFF1 that
preserve both satisfiability and unsatisfiability. The first translation targets
a classical many-sorted first-order logic, TFF0. It is included here for
illustrative purposes; more sophisticated encoding schemes are discussed in
Section~\ref{sec_related_work}. The second and third translations eliminate
ghost type arguments and type quantifiers, two features that are not directly
supported by ML-style formalisms, which otherwise are a good match for TFF1.

\subsection{Encoding into a Many-Sorted Logic} \label{ssec:tff0}

Our strategy for translating polymorphic types is to encode them as terms and
use a special binary predicate to encode type information. To avoid mixing types
and terms in the encoded problem, we introduce two sorts, $\typ$ and $\und$,
corresponding to the set of domains $\sorts$ and the universe $\univ$,
respectively. We give the symbols we generate for types the type $\typ$ while
keeping $\und$ for every other term.

Let $\DEL$ be a set of TFF1 sentences.
%, that is, closed and well-typed formulas.
We construct an equisatisfiable set of monomorphic two-sorted
formulas $\MON(\DEL)$ as follows.
%
To every type variable $\alpha$ in $\DEL$ or in the type signature of a function
symbol, we assign a fresh variable $\hat{\alpha}$ of sort $\typ$.
To every term variable $u$, we assign
a fresh variable $\hat{u}$ of sort $\und$.
To every type constructor $\kappa$ of arity $n$, we assign
a function symbol $\hat{\kappa} : \typ^n \to \typ$.
To every function symbol $f : \forall \alpha_1\dots\alpha_m .\; \tau_1 \times \dots \times \tau_n \to \tau$,
we assign a function symbol $\hat{f} : \typ^m \times \und^n \to \und$.
To every predicate symbol $p : \forall \alpha_1\dots\alpha_m .\; \tau_1 \times \dots \times \tau_n \to \omicron$
we assign a predicate symbol $\hat{p} : \typ^m \times \und^n \to \omicron$.
Finally, we introduce the predicate symbol $\typeof : \und \times \typ$.

The $\MON$ transformation translates TFF1 types, terms, and formulas
according to the following equations:
\begin{align*}
\MON(\alpha) &\eqdef \hat{\alpha} &
\MON(\kappa(\bar{\tau})) &\eqdef \hat{\kappa}(\MON(\bar{\tau})) \\
\MON(u) &\eqdef \hat{u} &
\MON(f(\bar{\tau},\,\bar{t}\,)) &\eqdef \hat{f}(\MON(\bar{\tau}),\,\MON(\bar{t}\,)) \\
\MON(t_1 \eq t_2) &\eqdef \MON(t_1) \eq \MON(t_2) &
\MON(p(\bar{\tau},\,\bar{t}\,)) &\eqdef \hat{p}(\MON(\bar{\tau}),\,\MON(\bar{t}\,)) \\
\MON(\lnot\, \varphi) &\eqdef \lnot\, \MON(\varphi) &
\MON(\varphi \rand \psi) &\eqdef \MON(\varphi) \rand \MON(\psi) \\
\MON(\forall u \ty \tau .\; \varphi) &\eqdef
\forall \hat{u} .\; \typeof(\hat{u},\, \MON(\tau)) \limp \MON(\varphi) &
\MON(\forall \alpha .\; \varphi) &\eqdef
\forall \hat{\alpha} .\; \MON(\varphi)
\end{align*}
%
\newcommand{\AxD}{\text{\sc Ax}_{\DEL}}%
\newcommand{\Inh}{\text{\sc Inh}}%
\newcommand{\Dom}{\mathrm{Dom}}%
%
The {\em inhabitation axiom}, $\Inh$, is the formula
$\forall \hat{\alpha}.\, \exists \hat{u} .\;
\typeof(\hat{u},\,\hat{\alpha}).$
For each function symbol $f :
\forall \alpha_1\dots\alpha_m .\; \tau_1 \times \dots \times \tau_n \to \tau$,
the associated {\em typing axiom\/} is the formula
$$
\forall \hat{\alpha}_1\dots\hat{\alpha}_m .\;
\forall \hat{u}_1\dots\hat{u}_n .\;
\typeof(\hat{f}(\hat{\alpha}_1,\dots,\hat{\alpha}_m,
\hat{u}_1,\dots,\hat{u}_n), \MON(\tau))%.
$$
We let $\AxD$ denote the set of typing axioms associated with all function
symbols occurring in $\DEL$.
%
Finally, we define
$$
\MON(\DEL) \eqdef \{ \MON(\varphi) \vb \varphi \in \DEL \} \mathrel\cup
\AxD \mathrel\cup \{ \Inh \}%.
$$
%
It is easy to see that $\MON$ converts TFF1 types into well-formed
terms of sort $\typ$, TFF1 terms into well-formed terms of sort $\und$,
and (not necessarily well-typed) TFF1 formulas into well-formed formulas.

\begin{theorem}[Soundness of $\BOLDMON$]%
\label{thm:mon_sound}%
\afterDot
If a set of sentences $\DEL$ is satisfiable in TFF1,
then $\MON(\DEL)$ is satisfiable in classical
many-sorted first-order logic with equality.
\end{theorem}
\begin{proof}
Let $\cM$ be a model of $\DEL$.
We construct an interpretation $\cI$ of $\MON(\DEL)$ as follows.
Let $\sorts$ and $\univ$ stand for
the set of domains and the universe in $\cM$, respectively.
In $\cI$, we define the domain of sort $\typ$ to be $\sorts$
and the domain of sort $\und$ to be $\univ$.
Each function symbol~$\hat{\kappa}$, function symbol $\hat{f}$,
or predicate symbol $\hat{p}$ is interpreted in $\cI$
exactly as the type constructor $\kappa$, function symbol $f$,
or predicate symbol $p$ in $\cM$.
The predicate symbol $\typeof$ is interpreted as the membership relation.
%This concludes the definition of interpretation $\cI$.

We show that for every type $\sigma$, term $t$,
and formula $\varphi$ occurring in $\DEL$,
for every variable valuation $\nu$ in $\cI$, we have
\begin{align*}
\llb \MON(\sigma) \rrb^\cI_{\nu} &= \llb \sigma \rrb^\cM_{\theta} &
\llb \MON(t) \rrb^\cI_{\nu} &= \llb t \rrb^\cM_{\theta,\xi} &
\llb \MON(\varphi) \rrb^\cI_{\nu} &= \llb \varphi \rrb^\cM_{\theta,\xi}
\end{align*}
where $\theta(\alpha) \inlineeqdef \nu(\hat{\alpha})$ and
$\xi(u) \inlineeqdef \nu(\hat{u})$ for every
type variable $\alpha$ and every variable $u$.
%
We prove these equalities by induction on the structure
of types, terms, and formulas. The only nontrivial case is
that of a quantified formula, $\forall u \ty \tau .\; \varphi$.
It is easy to see that any $a \in \univ$ belongs
to $\llb \tau \rrb^\cM_\theta$ if and only if
$\llb \typeof(\hat{u},\MON(\tau)) \rrb^\cI_{\nu\smash{[\hat{u}\,\mapsto\,a]}}{}_{\vphantom{]}}$
holds. Indeed, the latter is equivalent to
$a \in \llb \MON(\tau) \rrb^\cI_{\nu\smash{[\hat{u}\,\mapsto\,a]}}{}_{\vphantom{]}}$.
Since $\nu$ and $\nu[\hat{u} \mapsto a]$ produce the same
$\theta$ in $\cM$,
$\llb \MON(\tau) \rrb^\cI_{\nu\smash{[\hat{u}\,\mapsto\,a]}}{}_{\vphantom{]}} =
\llb \tau \rrb^\cM_\theta$.
Then
$\llb \forall \hat{u} .\; \typeof(\hat{u},\MON(\tau))
\limp \MON(\varphi) \rrb^\cI_{\nu}$ is exactly
$\llb \forall u \ty \tau .\; \varphi \rrb^\cM_{\theta,\xi}$
by induction hypothesis.

Now we only have to check that the typing axioms
$\AxD$ and the inhabitation axiom $\Inh$ hold in $\cI$.
This immediately follows from the definition of
interpretation in TFF1 and the first equality above.
\qed
\end{proof}

\begin{theorem}[Completeness of $\BOLDMON$] \label{thm:mon_compl}
Given a set of sentences $\DEL$, if $\MON(\DEL)$
is satisfiable in classical many-sorted first-order logic
with equality, then $\DEL$ is satisfiable in TFF1.
\end{theorem}
\begin{proof}
Let $\cM$ be a model of $\MON(\DEL)$. We first construct a model $\cM'$ of $\MON(\DEL)$
from $\cM$ by replacing every element $d$ in
the domain of $\typ$ by the set $D = \{\la a,\,d \ra \vb \exists a.\; \typeof^\cM(a,\,d)\}$
and updating the interpretations of type constructors
and function and predicate symbols in $\cM$ accordingly.
We can safely perform this substitution: Since the inhabitation
axiom $\Inh$ holds in $\cM$, every set~$D$ is nonempty, and clearly distinct
elements are mapped to distinct sets.
The predicate $\typeof^{\cM'\!}(a,\,D)$ holds if and only if
$D$ contains a pair of the form $\la a,\, d \ra$ for some $d$.
%
Below, $\pi_1$ and $\pi_2$ stand for the first and the second projection
of a pair, respectively.

We construct an interpretation $\cI$ of $\DEL$ as follows.
The set of domains $\sorts$ is the new domain
of $\typ$ in $\cM$. As usual, $\univ$ denotes the union
of all domains in $\sorts$. Note that some elements of
the domain of $\und$ may not appear in any pair in $\univ$.
%
The symbols of $\DEL$ are interpreted in $\cI$
according to the equations
\begin{align*}
\kappa^\cI(D_1,\dots,D_m) &\eqdef \hat{\kappa}{\,}^\cM(D_1,\dots,D_m) \\
f^\cI(D_1,\dots,D_m,\la a_1,d_1 \ra,\dots,\la a_n,d_n \ra) &\eqdef
\bigl\la \hat{f}{\,}^\cM(D_1,\dots,D_m,a_1,\dots,a_n),\, d \bigr\ra \\
p^\cI(D_1,\dots,D_m,\la a_1,d_1 \ra,\dots,\la a_n,d_n \ra) &\eqdef
\hat{p}{\,}^\cM(D_1,\dots,D_m,a_1,\dots,a_n)
\end{align*}
where
$\kappa$ is of arity $m$,
$p : \forall \alpha_1\dots\alpha_m .\; \tau_1 \times \dots \times \tau_n \to
\omicron$,
$f : \forall \alpha_1\dots\alpha_m .\; \tau_1 \times \dots \times \tau_n \to \tau$,
and $d$ is the fixed second coordinate of pairs in the domain
%
\[D = \llb \MON(\tau) \rrb^\cM_{[\hat{\alpha}_1\,\mapsto\,D_1,\dots,
\hat{\alpha}_m\,\mapsto\,D_m]} =
\llb \tau \rrb^\cI_{[\alpha_1\,\mapsto\,D_1,\dots,\alpha_m\,\mapsto\,D_m]}\]%.
%
Since the typing axioms $\AxD$ hold in $\cM$, we have
$\typeof^\cM(f^\cM(D_1,\dots,D_n,a_1,\dots,a_m), D)$,
and therefore, the result of $f^\cI$ belongs indeed to $D$.
%This concludes the definition of $\cI$.

Given a type context $\GAM$, a type valuation $\theta$,
and a variable valuation $\xi$, we say that they are \emph{admissible}
for a TFF1 formula $\varphi$ when the following conditions are satisfied:
\begin{itemize}
\item $\varphi$ is well-typed in context $\GAM$;
\item for every variable $v$ free in $\varphi$, no type variable
occurring in $\GAM(v)$ is bound in $\varphi$;
\item for every variable $v$ free in $\varphi$, we have $\xi(v) \in \evalT{\GAM(v)}$.
\end{itemize}
Obviously, any triple is admissible for a sentence.
We must show that for every type $\sigma$, term $t$, and formula $\varphi$,
and for all $\GAM$, $\theta$, $\xi$ admissible for $\varphi$, we have
\begin{align*}
\evalT{\sigma} &= \llb \MON(\sigma) \rrb^\cM_{\nu} &
\pi_1(\eval{t}) &= \llb \MON(t) \rrb^\cM_{\nu} &
\eval{\varphi} &= \llb \MON(\varphi) \rrb^\cM_{\nu}
\end{align*}
where $\nu(\hat{\alpha}) \inlineeqdef \theta(\alpha)$ and
$\nu(\hat{u}) \inlineeqdef \pi_1(\xi(u))$
for every type variable $\alpha$ and variable $u$.

The proof goes by induction on the structure of types, terms, and formulas.
There are three nontrivial cases:\ equality, quantification over a term
variable, and quantification over a type variable.

Let $\varphi$ be an equality $t_1 \eq t_2$.
Let $\la a_1,\, d_1 \ra$ be $\eval{t_1}$ and $\la a_2,\, d_2 \ra$ be $\eval{t_2}$.
By induction hypothesis, $\llb \MON(t_1) \rrb^\cM_{\nu} = a_1$ and
$\llb \MON(t_2) \rrb^\cM_{\nu} = a_2$. We must show $d_1 = d_2$.
By assumption, $\varphi$ is well-typed in $\GAM$.
Thus, $\GAM\,\vdash t_1 \ty \sigma$ and $\GAM\,\vdash t_2 \ty \sigma$
for some type~$\sigma$.
If $t_1$ is a variable $v$, then
$\eval{t_1} = \xi(v) \in \eval{\GAM(v)} = \evalT{\sigma}$. Otherwise,
$t_1$ is a function application $f(\sigma_1,\dots,\sigma_m,s_1,\dots,s_n)$,
for $f \ty
\forall \alpha_1\dots\alpha_m .\; \tau_1 \times \dots \times \tau_n \to \tau$.
Let $D_i = \evalT{\sigma_i}$ for every $i \in [1,m]$.
Then $\sigma = \tau[\sigma_1/\alpha_1,\dots,\sigma_n/\alpha_n]$ and
$\evalT{\sigma} = \llb \tau \rrb^\cI_{[\alpha_1 \,\mapsto\, D_1,\dots,
\alpha_n \,\mapsto\, D_n]}$.
By construction of $\cI$, $\eval{t_1} \in \evalT{\sigma}$.
By the same argument, $\eval{t_2} \in \evalT{\sigma}$.
Hence, $d_1 = d_2$ and $\eval{\varphi} = \llb \MON(\varphi) \rrb^\cM_{\nu}$.

Let $\varphi$ be a quantified formula $\forall u \ty \tau .\; \psi$.
We must show that for every pair $\la a,\, d \ra$ in $\evalT{\tau}$, we have
$\typeof^\cM(a, \llb \MON(\tau) \rrb^\cM_{\nu[\hat{u}\,\mapsto\,a]})$,
and vice versa, for every $a$ in the domain of $\und$, if
$\typeof^\cM(a, \llb \MON(\tau) \rrb^\cM_{\nu[\hat{u}\,\mapsto\,a]})$
holds, then there exists some $d$ such that $\la a,\, d \ra \in
\evalT{\tau}$.
%
Since term variables do not occur in types,
\[\llb \MON(\tau) \rrb^\cM_{\nu[\hat{u}\,\mapsto\,a]} =
\llb \tau \rrb^\cI_\theta\]%.
By construction of $\cM$,
$\typeof^\cM(a, \llb \tau \rrb^\cI_\theta)$
holds if and only if there is some $d'$ such that
$\la a,\, d' \ra \in \llb \tau \rrb^\cI_\theta$.
%
Now, notice that the triple $\GAM[u \mapsto \tau],
\theta,\xi[u \mapsto \la a,\, d \ra]$ is admissible for $\psi$.
Indeed, $\psi$ is well-typed in $\GAM[u \mapsto \tau]$,
and for every $v \in \FV(\psi)$, we have
\[\xi[u \mapsto \la a,\, d \ra](v) \in \evalT{\GAM[u \mapsto \tau](v)}\]%.
Also, if $\tau$ contains a type variable $\beta$ bound in $\psi$,
then $\beta$ is both free and bound in $\varphi$, which violates
the no-clash assumption.
%
Then, by induction hypothesis, $\eval{\forall u \ty \tau .\; \psi}$
is exactly $\llb \forall \hat{u} .\; \typeof(\hat{u},\MON(\tau))
\limp \MON(\psi) \rrb^\cM_{\nu}$.

Let $\varphi$ be a quantified formula $\forall \alpha .\; \psi$.
Let $D$ be an element of $\sorts$. Under the no-clash assumption,
formula $\psi$ is well-typed in $\GAM$, and for all
$v \in \FV(\psi) = \FV(\varphi)$, we have
$\evalG{\GAM(v)}_{\theta[\alpha\,\mapsto\,D]} = \evalT{\GAM(v)}$.
Then $\eval{\varphi} = \llb \MON(\varphi) \rrb^\cM_{\nu}$ by induction hypothesis.
\qed
\end{proof}

\subsection{Elimination of Ghost Type Arguments} \label{ssec:ghost}

%\footnote{Other relevant citations, please? What about Mizar?}.
% @ANDREI: I'd rather stick to "ML-style formalisms" here. Oddball systems
% based on set theories are better treated in the Related Work section.

ML-style formalisms, as implemented in Alt-Ergo~\cite{conchon08smt},
Boogie~\cite{Barnett06boogie}, HOL \cite{gordon-melham-1993}, HOL
Light~\cite{harrison-1996}, Isabelle\slash HOL~\cite{nipkow-et-al-2002},
Why3~\cite{boogie11why3}, and other systems, forbid explicit $\forall$ binders
in type signatures. Function and predicate symbols do not take explicit type
arguments; instead, the concrete instance of the symbol's type signature is
determined by the types of its term arguments, the type of the result, and
optional type annotations.

The natural translation from TFF1 to such a formalism would map $\forall
\alpha\beta.\; \alpha\times\beta\to\omicron$ (and $\forall \beta\alpha.\;
\alpha\times\beta\to\omicron$) to $\alpha\times\beta\to\omicron$, simply
omitting any $\forall$ binders. To compensate for TFF1's explicit type
arguments, type annotations are sometimes needed to guide the Hindley--Milner
type inference. This is slightly awkward but not really difficult.

The difficulties arise in conjunction with ghost type variables; for example,
the type $\forall\alpha.\;\omicron$ is translated to $\omicron$, and the
dependency on the type is lost.
%
To ease the adoption of TFF1 in such systems, we suggest a preprocessing step
that eliminates ghost type arguments. This step is lightweight, as it requires
only the introduction of a dummy term argument for each ghost type.
%In particular,
%it is the identity for formulas that do not rely on ghost type arguments.

%that is, the type variables in the symbol's type signature that
%do not appear in the quantifier-free matrix.

Let $\DEL$ be a set of sentences.
We construct an equisatisfiable set $\ELI(\DEL)$ as follows.
%
We introduce a new unary type constructor $\ghost$.
We replace every function symbol $f$ of type signature
$\forall \alpha_1\dots\alpha_n .\; \tau_1 \times \dots \times \tau_m \to \tau$
with a new function symbol $\hat{f}$ of type signature
$\forall \alpha_1\dots\alpha_n .\;
\ghost(\alpha_{i_1}) \times \dots \times \ghost(\alpha_{i_r}) \times
\tau_1 \times \dots \times \tau_m \to \tau$,
where $\alpha_{i_1},\dots,\alpha_{i_r}$ are the type
variables from the quantifier prefix that do not occur in
$\tau_1,\dots,\tau_m,\tau$.
Likewise, every predicate symbol $p \,\ty\,
\forall \alpha_1\dots\alpha_n .\; \tau_1 \times \dots \times \tau_m \to \omicron$
is replaced with a new predicate symbol $\hat{p} \,\ty\,
\forall \alpha_1\dots\alpha_n .\;
\ghost(\alpha_{i_1}) \times \dots \times \ghost(\alpha_{i_r}) \times
\tau_1 \times \dots \times \tau_m \to \omicron$,
where $\alpha_{i_1},\dots,\alpha_{i_r}$ are the type
variables from the quantifier prefix that do not occur in
$\tau_1,\dots,\tau_m$.
Finally, we add a ``witness'' constant $\wit$
of type signature $\forall \alpha.\;\ghost(\alpha)$.
The $\ELI$ transformation translates terms and atomic
formulas according to the following equations:
\begin{align*}
\ELI(u) \eqdef u
\quad\quad & \qquad\qquad\qquad\quad
\ELI(t_1 \eq t_2) \eqdef \ELI(t_1) \eq \ELI(t_2) \\
\ELI(f(\sigma_1,\dots,\sigma_n,t_1,\dots,t_m)) &\eqdef
\hat{f}(\sigma_1,\dots,\sigma_n,\wit(\sigma_{i_1}),\dots,\wit(\sigma_{i_r}),
\ELI(t_1),\dots,\ELI(t_m)) \\
\ELI(p(\sigma_1,\dots,\sigma_n,t_1,\dots,t_m)) &\eqdef
\hat{p}(\sigma_1,\dots,\sigma_n,\wit(\sigma_{i_1}),\dots,\wit(\sigma_{i_r}),
\ELI(t_1),\dots,\ELI(t_m))
\end{align*}
Given a formula $\varphi$ or a set of sentences $\DEL$,
$\ELI(\varphi)$ and $\ELI(\DEL)$ denote the result of
applying $\ELI$ to every atomic formula in $\varphi$ and
$\DEL$, respectively.

\begin{theorem} \label{thm:eli}
Any $\DEL$ is equisatisfiable to $\ELI(\DEL)$.
\end{theorem}
\begin{proof}
A model of $\DEL$ can be converted to a model of $\ELI(\DEL)$
as follows. We choose an arbitrary value $e$ and set the singleton
$\{ e \}$ as the domain of $\ghost(D)$ for any domain $D$.
Accordingly, $\wit$ evaluates to $e$ on any argument.
Interpretations of other function and predicate symbols are
adjusted in an obvious way.

To convert a model of $\ELI(\DEL)$
to a model of $\DEL$, we evaluate any functional symbol
$f$ on $D_1,\dots,D_n,a_1,\dots,a_m$ exactly as
$\hat{f}$ on $D_1,\dots,D_n,e_1,\dots,e_r,a_1,\dots,a_m$,
where each $e_j$ is the evaluation of $\wit$ on $D_{i_j}$;
likewise for predicate symbols.
\qed
\end{proof}

\subsection{Type Skolemization} \label{ssec:skol}

Another feature of TFF1 which is not universally supported
by other systems with polymorphic types is explicit
quantification over type variables.
For example, Coq and Boogie accept quantifiers over types%
\footnote{Mizar? Anybody else?}.
On the other side, the systems based on HOL as well as Why3 and
Alt-Ergo treat all type variables as implicitly universally
quantified at the top of a formula, which is similar to
the treatment of variables in clauses.
A simple and practical solution to translate TFF1 problems
for the systems of the second kind is type skolemization.
Unfortunately, not every TFF1 problem can be treated this way.

We introduce two transformations $\SKO^-$ and $\SKO^+$ to
perform type skolemization in premises and in goals, respectively
(the latter should be rather called ``type herbrandization'').
%Let us call a formula $\varphi$ {\em dependently typed} whenever
%it contains a quantifier over a type variable in the scope
%of a quantifier over a term variable%
%\footnote{We might take polarities into account, but then
%the proof of Theorem~\ref{thm:sko} wouldn't be so sweet.
%Types-under-values are nasty anyway.}.
The transformations $\SKO^-$ and $\SKO^+$ apply to
TFF1 formulas according to the following equations:
\begin{align*}
\SKO^-(p(\bar{\sigma},\bar{t})) &\eqdef p(\bar{\sigma},\bar{t}) &
\SKO^+(p(\bar{\sigma},\bar{t})) &\eqdef p(\bar{\sigma},\bar{t}) \\
\SKO^-(t_1 \eq t_2) &\eqdef t_1 \eq t_2 &
\SKO^+(t_1 \eq t_2) &\eqdef t_1 \eq t_2 \\
\SKO^-(\forall u \ty \tau .\; \varphi) &\eqdef \forall u \ty \tau .\; \varphi &
\SKO^+(\forall u \ty \tau .\; \varphi) &\eqdef \forall u \ty \tau .\; \varphi \\
\SKO^-(\varphi \rand \psi) &\eqdef \SKO^-(\varphi) \rand \SKO^-(\psi) &
\SKO^+(\varphi \rand \psi) &\eqdef \SKO^+(\varphi) \rand \SKO^+(\psi) \\
\SKO^-(\lnot\, \varphi) &\eqdef \lnot\, \SKO^+(\varphi) &
\SKO^+(\lnot\, \varphi) &\eqdef \lnot\, \SKO^-(\varphi) \\
\SKO^-(\forall \alpha .\; \varphi) &\eqdef \forall \alpha .\; \SKO^-(\varphi) &
\SKO^+(\forall \alpha .\; \varphi) &\eqdef
\SKO^+(\varphi[\kappa(\beta_1,\dots,\beta_n)/\alpha])
\end{align*}
where $\kappa$ is a fresh type constructor and $\beta_1,\dots,\beta_n$ are
the free type variables of $\forall \alpha .\; \varphi$.
Recall that TFF1 forbids quantifiers over type variables in the scope
of a quantifier over a term variable; otherwise, Skolem type constructors
would have to take term variables as arguments. This is why $\SKO^-$ and
$\SKO^+$ stop at the outermost quantifier over a term variable.

Given a set of TFF1 sentences $\DEL$,
$\SKO^-(\DEL)$ and $\SKO^+(\DEL)$ denote the result of applying
the corresponding transformations to every formula in $\DEL$.

\begin{theorem} \label{thm:sko}
Any $\DEL$ is equisatisfiable to $\SKO^-(\DEL)$.
\end{theorem}
\begin{proof}
It is easy to see that
skolemizing the $\typ$-sorted variables in $\MON(\DEL)$ gives
exactly $\MON(\SKO^-(\DEL))$ modulo renaming of Skolem symbols and
permutation of their arguments. Theorems~\ref{thm:mon_sound} and
\ref{thm:mon_compl} conclude the proof.
\qed
\end{proof}

Given a TFF1 problem that does not satisfy the aforementioned restriction,
one can submit it to a system like Isabelle/HOL or Alt-Ergo by encoding it
with $\MON$ or any other sound translation into monomorphic logic.

