%First-Order Logic with Polymorphic Types
% ^^^ sounds a bit too general -- could be the title of the entire paper almost
\section{Syntax and Semantics} \label{sec_logic}

\ourparagraph{Type expressions.}
We distinguish {\em first-order types}, assigned
to individual values, and {\em higher-order types\/},
which specify the type signature of function and predicate symbols.
%\footnote{We could also call these two kinds of type ``value-level types'' and
%``function-level types,'' respectively.}%
%%% @ANDREI: I'm fine with either terminology, but it seems hardly anybody uses
%%% the terminology from the footnote (try Google).
%
First-order types are built from {\em type variables\/}
and {\em type constructors\/} of fixed arity. Type constructors
of arity 0 are called {\em type constants}. We follow the usual
notation conventions of TPTP: Type variables start with an
uppercase letter and type constructors with a lowercase letter.
There are several predefined type constants, inherited from TFF0:
\verb+$i+ (also called \verb+$iType+),
\verb+$int+, \verb+$rat+, and \verb+$real+. We refer to the TFF0
specification \cite{TFF0} for the semantics of
\verb+$int+, \verb+$rat+, and \verb+$real+ and the predefined operations on
these types. %, and focus here on the nonarithmetic fragment of TFF1.
Here are a few examples of well-formed first-order types:
\verb+A+, \verb+list(A)+, \verb+list($i)+, \verb+map($int,+~\verb+list(A))+.

Higher-order types may take the following forms:
%
\begin{enumerate}
\item[(a)] a first-order type;
\item[(b)] the Boolean type \verb+$o+ (also called \verb+$oType+);
\item[(c)] {\tt ($T_1$\;*\;${\dots}$\;*\;$T_n$)\;>\;$T$} for $n > 0$,
where $T_1,\dots,T_n$ and $T$ are first-order types;
\item[(d)] {\tt ($T_1$\;*\;${\dots}$\;*\;$T_n$)\;>\;\$o} for $n > 0$,
where $T_1,\dots,T_n$ are first-order types;
\item[(e)] {\tt !>\ [$A_1$\;:\;\$tType,} {\tt ${\dots}$,} {\tt
$A_n$\;:\;\$tType]:\;$T$}, where $A_1,\dots,A_n$ are distinct type variables, $T$
has one of the previous four forms, and every type variable occurring in $T$
appears among $A_1,\dots,A_n$.
%The converse is not true: Some $A_i$ may not occur in $T$.
\end{enumerate}
%
We omit the parentheses in forms (c) and (d) if $n = 1$. The binder {\tt !>} in
form (e) denotes type-level universal quantifier.
A type that contains type variables (whether bound or free), or a term of such a
type, is {\em polymorphic}; terms and types that are not polymorphic are {\em
monomorphic}.

Form (a) is used for variables and monomorphic constants; form (b), for
propositional constants, including the predefined symbols \verb+$true+ and
\verb+$false+; form (c), for monomorphic functions; form (d), for monomorphic
predicates; and form (e), for polymorphic functions and predicates.
It is sometimes convenient to regard all the forms above as a special case of
the general syntax
\begin{center}
{\tt !>} {\tt [$A_1$\;:\;\$tType,\;${\dots}$,\;$A_m$\;:\;\$tType]:\;%
($T_1$\;*\;${\dots}$\;*\;$T_n$)\;>\;$\widehat T$}
\end{center}
where $m$ and $n$ may be 0 and $\widehat T$ may be any first-order type or
{\tt \$o}.

%A type with a quantifier prefix is called {\em polytype},
%otherwise we call it {\em monotype}.
%A first-order monomorphic type is called {\em sort}.
%Notice that a monotype can be a polymorphic type,
%i.e.~contain type variables.

%In the sequel, the term ``type'' means
%first-order type unless stated otherwise.
%%% @ANDREI: This convention is often violated. E.g. in "Function and
%%% predicate application below", many of the "types" are higher-order, e.g.
%%% "type instance" of a symbol...

\ourparagraph{Type declarations.} Type constructors,
like function and predicate symbols,
may optionally be declared prior to use.
For example, the following declarations introduce a type
constant {\tt bird}, a unary type constructor {\tt list},
and a binary type constructor {\tt map}:
\begin{quote}
\verb+tff(bird_t, type, bird: $tType).+
\par\smallskip
\verb+tff(list_t, type, list: $tType > $tType).+
\par\smallskip
\verb+tff(map_t, type, map: ($tType * $tType) > $tType).+
\end{quote}
Type constructors must be fully applied, and therefore
their arity can be %unambiguously
determined at the first occurrence.
%%% @ANDREI: Too early for this. TODO: move where it belongs (and edit)
%However, one should keep in mind that a type
%expression can occur in a position of a term (see below
%the examples of {\tt cons} and other polymorphic symbols).
%A TFF parser should refer to the type signatures of function
%and predicate symbols in order to know whether it parses
%a term or a type.

A declaration of a function or predicate symbol gives it a higher-order
type---the symbol's {\em type signature}. For example, the following
declarations introduce a monomorphic constant {\tt pi}, a polymorphic predicate
{\tt isEmpty}, and a pair of polymorphic functions {\tt cons} and {\tt lookup}:
\begin{quote}
\verb+tff(pi_t, type, pi: $real).+
\par\smallskip
\verb+tff(isEmpty_t, type, isEmpty : !> [A : $tType]: list(A) > $o).+
\par\smallskip
\verb+tff(cons_t, type,+\\
\verb+    cons : !> [A : $tType]: (A * list(A)) > list(A)).+
\par\smallskip
\verb+tff(lookup_t, type,+\\
\verb+    lookup : !> [A : $tType, B : $tType]: (map(A, B) * A) > B).+
\end{quote}
If a function or predicate symbol is used before being declared, a
default type signature is assumed:\ {\tt (\$i\;*\;${\dots}$\;*\;\$i)\;>\;\$i}
for functions and {\tt (\$i\;*\;${\dots}$\;*\;\$i)\;>\;\$o} for predicates.

Each type constructor, function symbol, and predicate symbol may be declared at
most once. If a symbol is declared after its first use, the declared signature
must agree with the default signature. All symbols share the same namespace; in
particular, a type constructor may not have the same name as a function or
predicate symbol.

%\footnote{Is this restriction present in TPTP FOF and TFF0? If not, we can
%lift it for TFF1.}.
%%% @ANDREI: FOF definitely shares the namespace for functions and symbols.
%%% TFF0 doesn't seem to mention anything but Sutcliffe's ToFoF cannot cope with
%%%   tff(foo_type, type, foo : $tType).
%%%   tff(foo_const, type, foo : foo).
%%%   tff(foo_ax, axiom, (![X : foo] : (X = foo))).
%%% Since TFFx is supposed to be about interoperability, in matters like these
%%% I tend not to put too heavy a burden on implementors.

\ourparagraph{Function and predicate application.} To keep the required type
inference to a minimum, every use of a polymorphic symbol must explicitly
specify the type instance. A function or predicate symbol with a type signature
\[\hbox{{\tt !>} {\tt [$A_1$\;:\;\$tType,\;${\dots}$,\;$A_m$\;:\;\$tType]:\;%
($T_1$\;*\;${\dots}$\;*\;$T_n$)\;>\;$\widehat T$}}\]
must be applied to $m$ type arguments and $n$ term arguments. Given the above
signatures for {\tt isEmpty}, {\tt cons}, and {\tt lookup}, the term
\[\hbox{\tt isEmpty(\$i,\;\,cons(\$i,\;V,\;nil(\$i)))}\]
and the atomic formula
\[\hbox{\tt lookup(\$int,\;\,list(A),\;\,M,\;\,2)}\]
are well-formed, assuming {\tt V} has type {\tt \$i}, {\tt A} has type {\tt
\$tType} (i.e., it is a type variable), and {\tt M} has type {\tt
map(\$int,\;list(A))}.

In keeping with TFF1's rank-1 polymorphic nature, type variables can only be
instantiated with first-order types. In particular, \verb+$o+ and \verb+$tType+
may not occur in type arguments of polymorphic symbols.

For systems that implement type inference, the following extension
of TFF1 might be useful. When a type argument of
a polymorphic symbol can be inferred automatically, it may be
replaced with an underscore ({\tt \_}), for example:
\[\hbox{{\tt isEmpty(\_,} {\tt cons(\_,\;V,\;nil(\_)))}}\]
% \footnote{Should this be part of {\tt SyntaxBNF}?}
% @ANDREI: I don't care much either way... SyntaxBNF is anyway very slack; I
% wouldn't be surprised if it could be used to parse C++. ;)
Although {\tt nil}'s type argument cannot be inferred locally from the types of
the term arguments, it can be deduced using the Hindley--Milner type inference.
The producer of a TFF1 problem must be aware of the type inference algorithm
implemented in the consumer to omit only the redundant type arguments.

\ourparagraph{Type variables and individual variables.}
Every variable in a TFF1 formula can be given a first-order type
at binding time:
\begin{verbatim}
    tff(list_not_empty, axiom,
      ! [B:bird, Bs:list(bird)]: ~ isEmpty(bird,cons(bird,B,Bs))).
\end{verbatim}
An untyped variable gets the type \verb+$i+.
Furthermore, every type variable occurring in a TFF1 formula
(in a type argument or in a type of a bound variable)
must be also bound:
\begin{verbatim}
    tff(lookup_set, axiom,
      ! [A:$tType, B:$tType, M:map(A,B), I:A, V:B]:
          lookup(A,B,set(A,B,M,I,V),I) = V).
\end{verbatim}
Notice that one can put type variables and ordinary variables
under the same quantifier. The order of variables is important:
if the type of an ordinary variable contains a type variable,
the latter must appear before the former%
\footnote{We can permit omitting the {\tt\$tType} annotations,
too, but should we? If an untyped variable can turn to be
a type variable or an {\tt\$i}-variable, then we must look
into the formula to know which it is.}.

Type variables can be bound both by universal and existential
quantifiers.
We allow such bindings to occur under equivalence, negation,
and other propositional connectives (though one might need
to eliminate upper equivalences to establish the polarity
of a quantifier) as well as under other quantifiers over
type variables.
However, a quantifier over a type variable cannot appear in
the scope of a quantifier over an ordinary variable in TFF1.
Let us briefly discuss our reasons for this restriction.

A statement like ``for every integer $N$ there exists a type
$A$ such that...'' essentially makes $A$ a dependent type.
On such statements, type skolemization (Section~\ref{ssec:skol})
is impossible, so that they cannot be easily translated to languages
that support type polymorphism but not explicit quantifiers over
types, the most important example being HOL and its derivatives.
Moreover, we believe that type handling in an automated prover
would be more difficult were such constructions allowed,
as that would require paramodulation into types.

That said, all our definitions in this paper, except for
Section~\ref{ssec:skol}, do not depend on this restriction.
The rules of type checking and the notion of interpretation
are directly applicable to non-restricted formulas, where
type variables can be bound in the scope of ordinary quantifiers.
The encoding into a monomorphic logic (Section~\ref{ssec:tff0})
is sound and complete on non-restricted formulas, and the proofs of
Theorems~\ref{thm:mon_sound} and \ref{thm:mon_compl} never assume
this restriction.
Our intent is, in particular, to prepare ground for future revisions
of the TFF format, where this restriction will be lifted and more
elaborate forms of dependent types are expected to appear.
At present, any implementation of TFF1 is free to accept
non-restricted problems and treat them according to the semantics
given in this paper.
Let us note that the Boogie
system~\cite{Barnett06boogie} handles explicit quantifiers over types,
and the encoding methods studied in \cite{leino10tacas} are devised
for a non-restricted setting.

Another way to introduce a variable is by a let-statement.
The initial revision of the TFF1 format allowed to bind a variable
to a term as well as to a formula (a variable thus bound has
``type'' \verb+$o+ and can only appear in a position of a formula)%
\footnote{Should we elaborate on the syntax of let?
It was already in TFF0, but it was not described in
the article on TFF0. The same about if/ite: should
we talk about them, though they are completely
orthogonal to polymorphism and types?}.
%In the former case,
%the syntax of binding is {\it variable}~{\tt :-}~{\it term\/} and
%the type of the variable is the type of the term. In the latter case,
%the syntax of binding is {\it variable}~{\tt :=}~{\it formula\/} and
%a variable thus bound has the ``type'' \verb+$o+ and
%can only appear in a position of a formula (notice that
%one cannot quantify over a variable of type \verb+$o+).
In TFF1, we additionally admit binding a type variable
to a first-order type%
%using the syntax {\it variable}~{\tt :>}~{\it type}%
\footnote{Since any first-order type is a well-formed TFF1 term,
we could reuse the existing syntax for these bindings.
But then suppose that {\tt foo} is undeclared and
we bind {\tt A} to it: {\tt A} {\tt :-} {\tt foo}.
Until {\tt A} is used
(as a type or as a value), we cannot know what it is.}.
For example,
the axiom \verb+list_not_empty+ above could be written as
follows:
\begin{verbatim}
    tff(list_not_empty, axiom,
      := [T :> bird]:
          ! [B:T, Bs:list(T)]: ~ isEmpty(T,cons(T,B,Bs))).
\end{verbatim}
One can put a mixed list of bindings in a let-statement;
in such lists each subsequent binding can refer
to the variables introduced by preceding ones%
\footnote{Is this true in TFF0? I didn't find any written
specification of multi-variable let.}.

The let-bindings can be eliminated from TFF1 formulas by simple
substitution (with renaming of bound variables where necessary
to avoid capture). For the sake of brevity, we do not consider
them in the following sections.

\ourparagraph{Notation.} From now on, we use standard
mathematical notation to write types, terms, and formulas.
We denote type variables with small Greek letters
$\alpha$, $\beta$, $\gamma$, type constructors
with letters $I$, $K$, $L$, and first-order
types with letters $T$ and $S$. Ordinary variables
are denoted $u$, $v$, $w$, $x$, $y$, $z$; function
symbols are denoted $f$, $g$, $h$; predicate symbols
are denoted $p$ and $q$. The letters $t$ and $s$ denote
terms and the letters $F$, $G$, $H$ denote formulas.
Sometimes, we write the names of type constructors,
function and predicate symbols using a fixed-width
font: {\tt list}, {\tt map}, {\tt cons}, {\tt set},
etc.

We use symbols ${\times}$, ${\to}$, and ${\ALL}$
%\footnote{We can also use ${\prod}$, but should we,
%given that there are no dependent types in TFF1?}
to write higher-order types. The Greek letter $\omicron$ denotes
the Boolean type {\tt \$o}. We treat equality ($\approx$),
negation ($\lnot$), conjunction ($\land$), and the universal
quantifier ($\forall$) as logical symbols and we treat
disjunction ($\lor$), implication ($\limp$), equivalence
($\lequ$), disequality ($\not\approx$), and the existential
quantifier ($\exists$) as abbreviations.
%The symbols $\top$ and $\bot$ stand for ``true'' and ``false'',
%respectively.

The set of type variables freely occurring in a formula $F$
(in the type arguments of polymorphic symbols or
in the types of bound variables) is denoted $\FVT(F)$.
The set of free ordinary variables of $F$
is denoted $\FV(F)$. We call $F$ {\em closed\/}
whenever both $\FVT(F)$ and $\FV(F)$ are empty.

A {\em type substitution\/} is a mapping of type variables
to first-order types. A {\em monomorphic\/} type substitution
maps every type variable either to itself or to a monomorphic type.
%
A type $T$ is said to {\em match\/} another type $T'$ whenever
there is a type substitution that instantiates $T$ to $T'$.
We use Greek letters $\tau$ and $\rho$ for type substitutions.
%
Ordinary substitutions that map variables to terms
are denoted with letters $\sigma$ and $\delta$.
The symbol $\circ$ denotes the composition
of two (type) substitutions:
$x(\sigma \circ \delta) \eqdef x\sigma\delta$.

\ourparagraph{Type checking.}
Let $\gamma$ be a {\em type context}, a function that maps
every variable symbol to a type.
A type judgement $\gamma \,\vdash t \ty T$ means that term $t$
is {\em well-typed\/} and has type $T$ in context $\gamma$.
A type judgement $\gamma \,\vdash F \ty \omicron$ means that formula $F$
is {\em well-typed\/} in $\gamma$.
We write $f \,\ty\, \forall \alpha_1\dots\alpha_n \,.\,
T_1 \times \dots \times T_m \to T$ and
$p \,\ty\, \forall \alpha_1\dots\alpha_n \,.\,
T_1 \times \dots \times T_m \to \omicron$ to specify
type signatures of function and predicate symbols;
notice that $n$ and $m$ can both be zero.

The typing rules of TFF1 are given in Figure~\ref{fig:typing}.
We write $\gamma[v \mapsto T]$ to denote a type context that maps
variable $v$ to type $T$ and every other variable $u$ to $\gamma(u)$.
In the last rule, $\alpha'$ is an arbitrary type variable that
occurs neither in $F$ nor in the values of $\gamma$.
The renaming is necessary to reject formulas like
$\forall\alpha\forall u\ty\alpha\forall\alpha\forall v\ty\alpha \,.\,
u \approx v$, where the types of $u$ and $v$ are actually different.
In order to simplify our subsequent definitions, we assume from now on
that no type variable can be both free and bound in the same formula;
we call this the {\em no-clash assumption}.
%Consequently, nested quantifiers on the same type
%variable are not allowed, either.
Then we can do without explicit renaming of type variables,
and the last typing rule is simply
$\frac{\gamma\, \,\vdash\, F \ty \omicron}{
\gamma\, \,\vdash\, \forall \alpha \,.\, F \,\ty\, \omicron}$.

\begin{figure}
\begin{center}
\begin{tabular}{c@{\qquad\qquad}c}
\multicolumn{2}{c}{$\displaystyle
\frac{}{\gamma\, \:\vdash\: v \ty \gamma\,(v)}$} \\[4ex]
\multicolumn{2}{c}{$\displaystyle
\frac{f \,\ty\, \forall \alpha_1\dots\alpha_n \,.\,
    T_1 \times \dots \times T_m \to T
\qquad
\gamma\, \,\vdash\, t_1 \ty T_1\tau
\quad\cdots\quad
\gamma\, \,\vdash\, t_m \ty T_m\tau
}{\gamma\, \:\vdash\:
f(\alpha_1\tau,\dots,\alpha_n\tau,t_1,\dots,t_m) \,\ty\, T\tau}
$} \\[4ex]
\multicolumn{2}{c}{$\displaystyle
\frac{p \,\ty\, \forall \alpha_1\dots\alpha_n \,.\,
    T_1 \times \dots \times T_m \to \omicron
\qquad
\gamma\, \,\vdash\, t_1 \ty T_1\tau
\quad\cdots\quad
\gamma\, \,\vdash\, t_m \ty T_m\tau
}{\gamma\, \:\vdash\:
p(\alpha_1\tau,\dots,\alpha_n\tau,t_1,\dots,t_m) \,\ty\, \omicron}
$} \\[4ex]
$\qquad\displaystyle
\frac{\gamma\, \,\vdash\, t_1 \ty T \qquad \gamma\, \,\vdash\, t_2 \ty T}{
\gamma\, \:\vdash\: t_1 \approx t_2 \,\ty\, \omicron}$ &
$\displaystyle
\frac{\gamma\, \,\vdash\, F \ty \omicron \qquad
\gamma\, \,\vdash\, G \ty \omicron}{
\gamma\, \,\vdash\, F \land G \,\ty\, \omicron}\qquad$ \\[4ex]
\multicolumn{2}{c}{
$\displaystyle
\frac{\gamma\, \,\vdash\, F \ty \omicron}{
\gamma\, \,\vdash\, \lnot F \,\ty\, \omicron}\qquad\qquad
\frac{\gamma[v \mapsto T] \,\vdash\, F \ty \omicron}{
\gamma\, \,\vdash\, \forall v \ty T .\, F \,\ty\, \omicron}\qquad\qquad
\frac{\gamma\, \,\vdash\, F[\alpha'/\alpha] \ty \omicron}{
\gamma\, \,\vdash\, \forall \alpha \,.\, F \,\ty\, \omicron}$}
\end{tabular}
\end{center}
\caption{Typing rules of TFF1}
\label{fig:typing}
\end{figure}

A closed TFF1 formula $H$ is {\em well-typed\/} if and only if
the judgement $\gamma\, \vdash H \ty \omicron$ is derivable
for any $\gamma$.
Obviously, if a closed formula is
well-typed in one type context, it is well-typed in any other one;
in what follows, we omit $\gamma$ and simply write
${} \vdash H \ty \omicron$.
Closed well-typed formulas are called {\em sentences}.

\ourparagraph{Interpretation.}
An interpretation $\cI$ for a given set of type constructors,
function symbols, and predicate symbols is constructed as follows.
We start with a non-empty collection $\sorts$ of non-empty sets,
which we call {\em domains}. The union, not necessarily disjoint,
of all domains is called {\em universe\/} and denoted $\univ$.

A type constructor $K$ of arity $n$ is interpreted as a function
$K^{\cI} : \sorts^n \to \sorts$.
Let $\theta$ be a {\em type valuation}, a function that maps every
type variable to a domain. We evaluate first-order types according
to the following equations:
\begin{align*}
\evalT{\alpha} &\eqdef \theta(\alpha) &
\evalT{K(T_1,\dots,T_n)} &\eqdef K^{\cI}(\evalT{T_1},\dots,\evalT{T_n})
\end{align*}
Since type evaluation depends only on the values of $\theta$
on the type variables occurring in a type, we write $\evalG{S}$
to denote the domain of a monomorphic type $S$. We also write
$\evalG{T}_{[\alpha_1\,\mapsto\,D_1,\dots,\alpha_n\,\mapsto\,D_n]}$
to evaluate a type whose free type variables
belong to $\alpha_1,\dots,\alpha_n$.

A predicate symbol $p$ of signature
$\forall \alpha_1\dots\alpha_n \,.\, T_1 \times \dots \times T_m
\to \omicron$ is interpreted as a relation
$p^{\cI} \subseteq \sorts^n \times \univ^m$.
A function symbol $f$ of signature
$\forall \alpha_1\dots\alpha_n \,.\, T_1 \times \dots \times T_m \to T$
is interpreted as a function
$f^{\cI}$ on $\sorts^n \times \univ^m$ that
maps any $n$ domains $D_1,\dots,D_n$ and
any $m$ elements of the universe
to an element of
$\evalG{T}_{[\alpha_1\,\mapsto\,D_1,\dots,\alpha_n\,\mapsto\,D_n]}$.
%Recall that every type variable occurring in a type signature
%must be bound, and therefore every type variable in $T$ belongs
%to $\{ \alpha_1,\dots,\alpha_n \}$.

Let $\xi$ be a {\em variable valuation}, a function that assigns
to every variable an element of $\univ$. We evaluate TFF1 terms
and formulas according to the following equations:
\begin{align*}
\eval{u} &\eqdef \xi(u) &
\eval{f(\bar{S},\bar{t})} &\eqdef f^\cI(\evalT{\bar{S}},\eval{\bar{t}}) \\
\eval{t_1 \approx t_2} &\eqdef (\eval{t_1} = \eval{t_2}) &
\eval{p(\bar{S},\bar{t})} &\eqdef p^\cI(\evalT{\bar{S}},\eval{\bar{t}}) \\
\eval{\lnot F} &\eqdef \lnot\, \eval{F} &
\eval{F \land G} &\eqdef \eval{F} \land\, \eval{G} \\
\eval{\forall u \ty T .\, F} &\eqdef \forall {a \in \evalT{T}} \,.\,
\evalG{F}_{\theta,\xi[u\,\mapsto\,a]} &
\eval{\forall \alpha \,.\, F} &\eqdef \forall {D \in \sorts} \,.\,
\evalG{F}_{\theta[\alpha\,\mapsto\,D],\xi} % \\
%\eval{\forall u \ty T .\, F} &\eqdef \!\!\!\!
%\bigwedge_{a \in \evalT{T}} \!
%\evalG{F}_{\theta,\xi[u\,\mapsto\,a]} &
%\eval{\forall \alpha \,.\, F} &\eqdef
%\bigwedge_{D \in \sorts}\;
%\evalG{F}_{\theta[\alpha\,\mapsto\,D],\xi}
\end{align*}
Here, $\bar{S}$ and $\bar{t}$ are sequences of types and terms, respectively.
The expression $\xi[u \mapsto a]$ stands for the function that
maps variable $u$ to $a$ and every other variable $v$ to $\xi(v)$.
Likewise, $\theta[\alpha \mapsto D]$ is the function that maps
type variable $\alpha$ to domain $D$ and every other type
variable $\beta$ to $\theta(\beta)$. In what follows,
we omit the irrelevant subscripts and write $\evalG{F}$
to denote the evaluation of a closed formula.

We say that a sentence $F$ is {\em true} in an interpretation $\cI$
and denote it by $\cI \models F$ if and only if $\evalG{F}$ is true.
The interpretation $\cI$ is called then a {\em model\/} of $F$.
A sentence that has a model is called {\em satisfiable}.
A sentence that is true in every interpretation is called {\em valid}.
These notions are extended to sets and sequents of TFF1 sentences in
a usual way.

