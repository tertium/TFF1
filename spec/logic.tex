%First-Order Logic with Polymorphic Types
% ^^^ sounds a bit too general -- could be the title of the entire paper almost
\section{Syntax and Semantics} \label{sec_logic}

\ourparagraph{Type expressions.}
We distinguish {\em types}, assigned
to individual values, and the {\em type signatures\/} of function and predicate symbols.
Types are built from {\em type variables\/}
and {\em type constructors\/} of fixed arity. Type constructors
of arity 0 are called {\em type constants}. We follow the usual
notation conventions of TPTP: Type variables start with an
uppercase letter and type constructors with a lowercase letter.
The types \verb+A+, \verb+list(A)+, \verb+list($i)+, and
\verb+map($int,+~\verb+list(B))+ are all examples of well-formed types.

TFF1 includes several predefined type constants, inherited from TFF0.
The type \verb+$i+ (also called \verb+$iType+) of individuals is predefined
but has no peculiar semantics, whereas the arithmetic types
\verb+$int+, \verb+$rat+, and \verb+$real+ only have infinite models. We refer
to the TFF0 specification \cite{TFF0} for the semantics of
\verb+$int+, \verb+$rat+, and \verb+$real+ and the predefined operations on
these types. %, and focus here on the nonarithmetic fragment of TFF1.

Type signatures may take the following forms:
%
\begin{enumerate}
\item[(a)] a type;
\item[(b)] the Boolean type \verb+$o+ (also called \verb+$oType+);
\item[(c)] {\tt ($T_1$\;*\;${\cdots}$\;*\;$T_n$)\;>\;$T$} for $n > 0$,
where $T_1,\dots,T_n$ and $T$ are types;
\item[(d)] {\tt ($T_1$\;*\;${\cdots}$\;*\;$T_n$)\;>\;\$o} for $n > 0$,
where $T_1,\dots,T_n$ are types;
\item[(e)] {\tt !>\ [$A_1$\;:\;\$tType,} {\tt ${\dots}$,} {\tt
$A_n$\;:\;\$tType]:\ $T$}, where $A_1,\dots,A_n$ are distinct type variables, $T$
has one of the previous four forms, and every type variable occurring in $T$
appears among the $A_i$'s.
%The converse is not true: Some $A_i$ cannot occur in $T$.
\end{enumerate}
%
We omit the parentheses in forms (c) and (d) if $n = 1$. The binder {\tt !>} in
form (e) denotes type-level universal quantifier. A type that binds type
variables, or a term declared with {\tt !>}-bound variables, is {\em
polymorphic}; terms and types that are not polymorphic are {\em monomorphic}.
Notice in particular that {\tt !>\;[$A$\;:\;\$tType]:\;list(A)} is polymorphic
but {\tt list(A)} is monomorphic.

Form (a) is used for variables and monomorphic constants; form (b), for
propositional constants, including the predefined symbols \verb+$true+ and
\verb+$false+; form (c), for monomorphic functions; form (d), for monomorphic
predicates; and form (e), for polymorphic functions and predicates.
It is sometimes convenient to regard all the forms above as a special case of
the general syntax
\begin{center}
{\tt !>} {\tt [$A_1$\;:\;\$tType,\;${\dots}$,\;$A_m$\;:\;\$tType]:} {\tt
($T_1$\;*\;${\cdots}$\;*\;$T_n$)\;>\;$\widehat T$}
\end{center}
where $m$ and $n$ may be 0 and $\widehat T$ may be any type or {\tt \$o}.

%A type with a quantifier prefix is called {\em polytype},
%otherwise we call it {\em monotype}.
%A monomorphic type is called {\em sort}.
%Notice that a monotype can be a polymorphic type,
%i.e.~contain type variables.

\ourparagraph{Type declarations.} Type constructors,
like function and predicate symbols,
may optionally be declared prior to use.
For example, the following declarations introduce a type
constant {\tt bird}, a unary type constructor {\tt list},
and a binary type constructor {\tt map}:
\begin{quote}
\verb+tff(bird_t, type, bird: $tType).+
\par\smallskip
\verb+tff(list_t, type, list: $tType > $tType).+
\par\smallskip
\verb+tff(map_t, type, map: ($tType * $tType) > $tType).+
\end{quote}
Type constructors must be fully applied, and therefore
their arity can be %unambiguously
determined at the first occurrence.
%%% @ANDREI: Too early for this. TODO: move where it belongs (and edit)
%However, one should keep in mind that a type
%expression can occur in a position of a term (see below
%the examples of {\tt cons} and other polymorphic symbols).
%A TFF parser should refer to the type signatures of function
%and predicate symbols in order to know whether it parses
%a term or a type.

A declaration of a function or predicate symbol specifies its {\em type
signature}. For example, the following declarations introduce a monomorphic
constant {\tt pi}, a polymorphic predicate
{\tt is\_empty}, and a pair of polymorphic functions {\tt cons} and {\tt lookup}:
\begin{quote}
\verb+tff(pi_t, type, pi: $real).+
\par\smallskip
\verb+tff(is_empty_t, type, is_empty : !> [A : $tType]: list(A) > $o).+\kern-10mm
\par\smallskip
\verb+tff(cons_t, type,+\\
\verb+    cons : !> [A : $tType]: (A * list(A)) > list(A)).+
\par\smallskip
\verb+tff(lookup_t, type,+\\
\verb+    lookup : !> [A : $tType, B : $tType]: (map(A, B) * A) > B).+
\end{quote}
If a function or predicate symbol is used before being declared, a
default type signature is assumed:\ {\tt (\$i\;*\;${\cdots}$\;*\;\$i)\;>\;\$i}
for functions and {\tt (\$i\;*\;${\cdots}$\;*\;\$i)\;>\;\$o} for predicates.

Each type constructor, function symbol, and predicate symbol may be declared at
most once. If a symbol is declared after its first use, the declared signature
must agree with the default signature. All symbols share the same namespace; in
particular, a type constructor cannot have the same name as a function or
predicate symbol.

%\footnote{Is this restriction present in TPTP FOF and TFF0? If not, we can
%lift it for TFF1.}.
%%% @ANDREI: FOF definitely shares the namespace for functions and symbols.
%%% TFF0 doesn't seem to mention anything but Sutcliffe's ToFoF cannot cope with
%%%   tff(foo_type, type, foo : $tType).
%%%   tff(foo_const, type, foo : foo).
%%%   tff(foo_ax, axiom, (![X : foo] : (X = foo))).
%%% Since TFFx is supposed to be about interoperability, in matters like these
%%% I tend not to put too heavy a burden on implementors.

\ourparagraph{Function and predicate application.} To keep the required type
inference to a minimum, every use of a polymorphic symbol must explicitly
specify the type instance. A function or predicate symbol with a type signature
\[\hbox{{\tt !>} {\tt [$A_1$\;:\;\$tType,\;${\dots}$,\;$A_m$\;:\;\$tType]:\;%
($T_1$\;*\;${\cdots}$\;*\;$T_n$)\;>\;$\widehat T$}}\]
must be applied to $m$ type arguments and $n$ term arguments. Given the above
signatures for {\tt is\_empty}, {\tt cons}, and {\tt lookup}, the term
\[\hbox{\tt lookup(\$int,\;\,list(A),\;\,M,\;\,2)}\]
and the atomic formula
\[\hbox{\tt is\_empty(\$i,\;\,cons(\$i,\;V,\;nil(\$i)))}\]
are well-formed, assuming {\tt A} has type {\tt
\$tType} (i.e., it is a type variable), {\tt M} has type {\tt
map(\$int,\;list(A))}, and {\tt V} has type {\tt \$i}.

In keeping with TFF1's rank-1 polymorphic nature, type variables can only be
instantiated with actual types. In particular, \verb+$o+ and \verb+$tType+
cannot occur in type arguments of polymorphic symbols.

For systems that implement type inference, the following extension
of TFF1 might be useful. When a type argument of
a polymorphic symbol can be inferred automatically, it may be
replaced with an underscore ({\tt \_}), for example:
\[\hbox{{\tt is\_empty(\_,} {\tt cons(\_,\;V,\;nil(\_)))}}\]
% \footnote{Should this be part of {\tt SyntaxBNF}?}
% @ANDREI: I don't care much either way... SyntaxBNF is anyway very slack; I
% wouldn't be surprised if it could be used to parse C++. ;)
Although {\tt nil}'s type argument cannot be inferred locally from the types of
the term arguments, it can be deduced using the Hindley--Milner type inference.
The producer of a TFF1 problem must be aware of the type inference algorithm
implemented in the consumer to omit only the redundant type arguments.

\ourparagraph{Type variables and individual variables.}
Every variable in a TFF1 formula must be bound. It can be given a type at
binding time:
\begin{quote}
\begin{verbatim}
tff(bird_list_not_empty, axiom,
    ![B : bird, Bs : list(bird)]:
        ~ is_empty(bird, cons(bird, B, Bs))).
\end{verbatim}
\end{quote}
If the type and the preceding colon ({\tt :}) are omitted, the variable is given
the type~\verb+$i+. Every type variable occurring in a TFF1 formula
(whether in a type argument or in the type of a bound variable)
must also be bound:
\begin{quote}
\begin{verbatim}
tff(lookup_set, axiom,
    ![A : $tType, B : $tType, M : map(A, B), I : A, V : B]:
        lookup(A, B, set(A, B, M, I, V), I) = V).
\end{verbatim}
\end{quote}
A single quantifier cluster can bind both type variables and term variables. If
the type of a term variable contains a type variable, the latter must be bound
before the former.
%\footnote{We can permit omitting the {\tt\$tType} annotations,
%too, but should we? If an untyped variable can turn to be
%a type variable or an {\tt\$i}-variable, then we must look
%into the formula to know which it is.}.
%%% @ANDREI: We shouldn't allow that. Chances are that some implementations
%%% would get that wrong.


% (one might need
% to eliminate upper equivalences to establish the polarity
% of a quantifier)
%%% @ANDREI: What is an _upper_ equivalence? An outer one? I'd rather postpone
%%% the discussion on polarity until the part that treats skolemization. It is
%%% enough here to say "including equivalence", to hint at the issue, IMO.

Universal and existential quantifiers over type variables are allowed under the
propositional connectives, including equivalence, as well as under other
quantifiers over type variables, but not in the scope of a quantifier over a
term variable.
Rationale: A statement of the form ``for every integer $N$, there exists a type
$A$ such that $\ldots$'' effectively makes $A$ a dependent type.
On such statements, type skolemization (Section~\ref{ssec:skol}) is impossible,
and there is no easy translation to ML-style polymorphic formalisms,
such as HOL \cite{gordon-melham-1993}. Moreover, type handling in an automatic
prover would be more difficult were such constructions allowed, since they
require paramodulation into types.

On the other hand, only type skolemization requires this restriction on type
variables. The rules of type checking and the notion of interpretation are
directly applicable to unrestricted formulas. The encoding into a monomorphic
logic (Section~\ref{ssec:tff0}) is sound and complete on unrestricted formulas,
and the proofs of Theorems \ref{thm:mon_sound}~and~\ref{thm:mon_compl}
require no adjustments. This prepares the ground for TFF2, which is expected to lift the
restriction and support more elaborate forms of dependent types. Implementations
of TFF1 are encouraged to support unrestricted formulas, treating them according
to the semantics given here, if practicable.

Another way to introduce a variable is via the ``let'' construct.
A recent extension of the TFF0 format, discussed at the 7th TPTP Tea Party in
Wroc≈Çaw and not yet implemented, allows to introduce a function or predicate
locally. For example, the formulas
\begin{center}
\begin{tabular}{l}
{\tt :=\;[X\;:\;\$int,\;f(X)\;=\;g(X,\;X)]:\;p(f(a))} \\[\smallskipamount]
{\tt :=\;[X\;:\;\$int,\;p(X)\;<=>\;q(X,\;X)]:\;p(a)}
\end{tabular}
\end{center}
expand to {\tt p(g(a,\;a))} and {\tt q(a,\;a)}, respectively
\cite{geoff-tptptp-notes}.
Similarly, TFF1 admits binding a type~$T$ to $K(\alpha_1, \ldots,
\alpha_n)$, where $\alpha_1, \ldots, \alpha_n$ are distinct type variables bound
in $T$, using the syntax $K(\alpha_1, \ldots, \alpha_n)$~{\tt :>}~$T$ inside
the ``let'' binder.
%
%bind a variable
%to a term as well as to a formula (a variable thus bound has
%``type'' \verb+$o+ and can only appear in a position of a formula)
%%% @ANDREI: The proposed syntax is actually more general.
%
%\footnote{Should we elaborate on the syntax of let?
%It was already in TFF0, but it was not described in
%the article on TFF0. The same about if/ite: should
%we talk about them, though they are completely
%orthogonal to polymorphism and types?}.
%In the former case,
%the syntax of binding is {\it variable}~{\tt :-}~{\it term\/} and
%the type of the variable is the type of the term. In the latter case,
%the syntax of binding is {\it variable}~{\tt :=}~{\it formula\/} and
%a variable thus bound has the ``type'' \verb+$o+ and
%can only appear in a position of a formula (notice that
%one cannot quantify over a variable of type \verb+$o+).
%
%\footnote{Since any type is a well-formed TFF1 term,
%we could reuse the existing syntax for these bindings.
%But then suppose that {\tt foo} is undeclared and
%we bind {\tt A} to it: {\tt A} {\tt :-} {\tt foo}.
%Until {\tt A} is used
%(as a type or as a value), we cannot know what it is.}.
For example, the axiom \verb+bird_list_not_empty+ above could also be as
follows:
\begin{quote}
\begin{verbatim}
tff(bird_list_not_empty, axiom,
    := [b :> bird, A : $tType, c(A) :> list(A)]:
        ![B : b, Bs : c(b)]: ~ is_empty(b, cons(b, B, Bs))).
\end{verbatim}
\end{quote}
%One can put a mixed list of bindings in a let-statement;
%in such lists each subsequent binding can refer
%to the variables introduced by preceding ones%
%\footnote{Is this true in TFF0? I didn't find any written
%specification of multi-variable let.}.
%
The ``let'' bindings can be eliminated from TFF1 formulas using capture-avoiding
substitution. Hence we do not need to consider them in the rest of this
specification.

\ourparagraph{Notation.} In the sequel, we use standard
mathematical notation to write types, terms, and formulas. Our conventions
for metavariables are summarized below.
%
\begin{center}
\begin{tabular}{l@{\enskip}l@{\qquad}l@{\enskip}l}
Type variables: & $\alpha,$ $\beta$ &
  Function symbols: & $f,$ $g,$ $h$ \\
Type constructors: & $I,$ $K,$ $L$ &
  Predicate symbols: & $p,$ $q$ \\
Types: & $T,$ $S$ &
  Terms: & $t,$ $s$ \\
Term variables: & $u,$ $v,$ $w,$ $x,$ $y,$ $z$ &
  Formulas: & $F,$ $G,$ $H$
\end{tabular}
\end{center}
%
%We write the names of type constructors, function, and predicate symbols using a
%fixed-width font:\ {\tt list}, {\tt map}, {\tt cons}, {\tt set}.
%% @ANDREI: There were very few examples of this in the rest of the document (lessEq and isOrdered) and
%% it was obvious from the context what they were. Also, I'm trying italics for those, to mix
%% better with the maths; but I'm using the macro \sym, so it's easy to change.

We use the symbols ${\times}$, ${\to}$, and ${\ALL}$
%\footnote{We can also use ${\prod}$, but should we,
%given that there are no dependent types in TFF1?}
to write type signatures, and write $\omicron$ (lowercase omicron) for the
Boolean type {\tt \$o}. For ease of presentation, it is convenient to treat
equality ($\eq$), negation ($\lnot$), conjunction ($\land$), and the universal
quantifier ($\forall$) as logical symbols and regard disjunction ($\lor$),
implication ($\limp$), equivalence ($\lequ$), disequality ($\not\eq$), and the
existential quantifier ($\exists$) as abbreviations.
%The symbols $\top$ and $\bot$ stand for ``true'' and ``false'',
%respectively.

Equality can be seen as a polymorphic predicate with the signature
$\forall\alpha.\; \alpha\times\alpha\to\omicron$, but the type instance is
implicitly specified by the type of the arguments, instead of explicitly via a
type argument.

The set of type variables occurring freely in a formula $F$
(in the type arguments of polymorphic symbols or
in the types of bound variables) is denoted by $\FVT(F)$.
The set of free ordinary variables of $F$
is denoted by $\FV(F)$. The formula $F$ is {\em closed\/}
if both $\FVT(F)$ and $\FV(F)$ are empty.

A {\em type substitution\/} is a mapping of type variables
to types. A {\em monomorphic\/} type substitution
maps every type variable either to itself or to a monomorphic type.
%
A type $T$ is said to {\em match\/} another type $T'$ whenever there exists a
type substitution~$\rho$ such that $T\rho = T'$. We reserve $\rho$ for type
substitutions and $\sigma$ for term substitutions.
%
The symbol $\circ$ denotes the composition
of two substitutions:\ 
$x(\sigma \circ \sigma') \eqdef (x\sigma)\sigma' = x\sigma\sigma'$.

\ourparagraph{Type checking.}
Let $\GAM$ be a {\em type context}, a function that maps
every variable symbol to a type.
A type judgment $\GAM \,\vdash t \ty T$ expresses that that term $t$
is {\em well-typed\/} and has type $T$ in context $\GAM$.
A type judgment $\GAM \,\vdash F \ty \omicron$ expresses that formula $F$
is {\em well-typed\/} in $\GAM$.
We write $f \ty \forall \alpha_1\dots\alpha_m .\;
T_1 \times \dots \times T_n \to T$ and
$p \ty \forall \alpha_1\dots\alpha_m .\;
T_1 \times \dots \times T_n \to \omicron$ to specify
type signatures of function and predicate symbols,
where both $m$ and $n$ can be 0.

The typing rules of TFF1 are given in Figure~\ref{fig:typing}.
We write $\GAM[u \mapsto T]$ to denote a type context that maps
variable $u$ to type $T$ and every other variable $v$ to $\GAM(v)$.
In the last rule, $\alpha'$ is an arbitrary type variable that
occurs neither in $F$ nor in the values of~$\GAM$.
The renaming is necessary to reject formulas such as
$\forall\alpha.\:\forall u\ty\alpha.\:\forall\alpha.\:\forall v\ty\alpha.\;
u \eq v$, where the types of $u$ and $v$ are actually different.
In order to simplify our subsequent definitions, we assume from now on
that no type variable can be both free and bound in the same formula;
we call this the {\em no-clash assumption}.
%Consequently, nested quantifiers on the same type
%variable are not allowed, either.
Then we can do without explicit renaming of type variables,
and the last typing rule's antecedent  is simply
$\GAM \,\vdash\, F \ty \omicron$.

\begin{figure}
\begin{center}
\begin{tabular}{c@{\qquad\qquad}c}
\multicolumn{2}{c}{$\displaystyle
\ourfrac{}{\GAM \,\vdash\, v \ty \GAM(v)}$} \\[4ex]
\multicolumn{2}{c}{$\displaystyle
\ourfrac{f \ty \forall \alpha_1\dots\alpha_m .\;
    T_1 \times \dots \times T_n \to T
\qquad
\GAM \,\vdash\, t_1 \ty T_1\,\rho
\quad\cdots\quad
\GAM \,\vdash\, t_n \ty T_n\,\rho
}{\GAM \,\vdash\,
f(\alpha_1\,\rho,\>\dots,\>\alpha_m\,\rho,\>t_1,\>\dots,\>t_n) \ty T\rho}
$} \\[4ex]
\multicolumn{2}{c}{$\displaystyle
\ourfrac{p \ty \forall \alpha_1\dots\alpha_m .\;
    T_1 \times \dots \times T_n \to \omicron
\qquad
\GAM \,\vdash\, t_1 \ty T_1\,\rho
\quad\cdots\quad
\GAM \,\vdash\, t_n \ty T_n\,\rho
}{\GAM \,\vdash\,
p(\alpha_1\,\rho,\>\dots,\>\alpha_m\,\>\rho,\>t_1,\>\dots,\>t_n) \ty \omicron}
$} \\[4ex]
$\qquad\displaystyle
\ourfrac{\GAM \,\vdash\, t_1 \ty T \qquad \GAM \,\vdash\, t_2 \ty T}{
\GAM \,\vdash\, t_1 \eq t_2 \ty \omicron}$ &
$\displaystyle
\ourfrac{\GAM \,\vdash\, F \ty \omicron \qquad
\GAM \,\vdash\, G \ty \omicron}{
\GAM \,\vdash\, F \land G \ty \omicron}\qquad$ \\[4ex]
\multicolumn{2}{c}{
$\displaystyle
\ourfrac{\GAM \,\vdash\, F \ty \omicron}{
\GAM \,\vdash\, \lnot\, F \ty \omicron}\qquad\qquad
\ourfrac{\GAM[v \mapsto T] \,\vdash\, F \ty \omicron}{
\GAM \,\vdash\, \forall v \ty T .\; F \ty \omicron}\qquad\qquad
\ourfrac{\GAM \,\vdash\, F[\alpha'\!/\alpha] \ty \omicron}{
\GAM \,\vdash\, \forall \alpha .\; F \ty \omicron}$}
\end{tabular}
\end{center}
\caption{Typing rules of TFF1}
\label{fig:typing}
\end{figure}

A closed TFF1 formula $H$ is {\em well-typed\/} if and only if
the judgment $\GAM \vdash H \ty \omicron$ is derivable
for any $\GAM$.
Obviously, if a closed formula is
well-typed in one type context, it is well-typed in any other one;
in what follows, we omit $\GAM$ and simply write
${} \vdash H \ty \omicron$.
Closed well-typed formulas are called {\em sentences}.

\ourparagraph{Interpretation.}
An interpretation $\cI$ for a given set of type constructors,
function symbols, and predicate symbols is constructed as follows.
We start with a non-empty collection $\sorts$ of non-empty sets,
which we call {\em domains}. The union of all (not necessarily disjoint) domains
is called {\em universe\/} and denoted by $\univ$.

A type constructor $K$ of arity $n$ is interpreted as a function
$K^{\cI} : \sorts^n \to \sorts$.
Let $\theta$ be a {\em type valuation}, a function that maps every
type variable to a domain. We evaluate types according
to the following equations:
\begin{align*}
\evalT{\alpha} &\eqdef \theta(\alpha) &
\evalT{K(T_1,\dots,T_n)} &\eqdef K^{\cI}(\evalT{T_1},\dots,\evalT{T_n})
\end{align*}
Since type evaluation depends only on the values of $\theta$
on the type variables occurring in a type, we write $\evalG{S}$
to denote the domain of a monomorphic type $S$. We also write
$\evalG{T}_{[\alpha_1\,\mapsto\,D_1,\dots,\alpha_n\,\mapsto\,D_n]}$
to evaluate a type whose free type variables
belong to $\alpha_1,\dots,\alpha_n$.

A predicate symbol $p$ of signature
$\forall \alpha_1\dots\alpha_n .\; T_1 \times \dots \times T_m
\to \omicron$ is interpreted as a relation
$p^{\cI} \subseteq \sorts^n \times \univ^m$.
A function symbol $f$ of signature
$\forall \alpha_1\dots\alpha_n .\; T_1 \times \dots \times T_m \to T$
is interpreted as a function
$f^{\cI}$ on $\sorts^n \times \univ^m$ that
maps any $n$ domains $D_1,\dots,D_n$ and
any $m$ elements of the universe
to an element of
$\evalG{T}_{[\alpha_1\,\mapsto\,D_1,\dots,\alpha_n\,\mapsto\,D_n]}$.
%Recall that every type variable occurring in a type signature
%must be bound, and therefore every type variable in $T$ belongs
%to $\{ \alpha_1,\dots,\alpha_n \}$.

Let $\xi$ be a {\em variable valuation}, a function that assigns
to every variable an element of $\univ$. We evaluate TFF1 terms
and formulas according to the following equations:
\begin{align*}
\eval{u} &\eqdef \xi(u) &
\eval{f(\bar{S},\bar{t})} &\eqdef f^\cI(\evalT{\bar{S}},\eval{\bar{t}}) \\
\eval{t_1 \eq t_2} &\eqdef (\eval{t_1} = \eval{t_2}) &
\eval{p(\bar{S},\bar{t})} &\eqdef p^\cI(\evalT{\bar{S}},\eval{\bar{t}}) \\
\eval{\lnot\, F} &\eqdef \lnot\, \eval{F} &
\eval{F \land G} &\eqdef \eval{F} \land\, \eval{G} \\
\eval{\forall u \ty T .\; F} &\eqdef \forall {a \in \evalT{T}} .\;
\evalG{F}_{\theta,\xi[u\,\mapsto\,a]} &
\eval{\forall \alpha .\; F} &\eqdef \forall {D \in \sorts} .\;
\evalG{F}_{\theta[\alpha\,\mapsto\,D],\xi} % \\
%\eval{\forall u \ty T .\; F} &\eqdef \!\!\!\!
%\bigwedge_{a \in \evalT{T}} \!
%\evalG{F}_{\theta,\xi[u\,\mapsto\,a]} &
%\eval{\forall \alpha .\; F} &\eqdef
%\bigwedge_{D \in \sorts}\;
%\evalG{F}_{\theta[\alpha\,\mapsto\,D],\xi}
\end{align*}
Here, $\bar{S}$ and $\bar{t}$ are sequences of types and terms, respectively.
The expression $\xi[u \mapsto a]$ stands for the function that
maps variable $u$ to $a$ and every other variable $v$ to $\xi(v)$.
Likewise, $\theta[\alpha \mapsto D]$ is the function that maps
type variable $\alpha$ to domain $D$ and every other type
variable $\beta$ to $\theta(\beta)$. In what follows,
we omit the irrelevant subscripts and write $\evalG{F}$
to denote the evaluation of a closed formula.

We say that a sentence $F$ is {\em true} in an interpretation $\cI$
and denote it by $\cI \models F$ if and only if $\evalG{F}$ is true.
The interpretation $\cI$ is called then a {\em model\/} of $F$.
A sentence that has a model is called {\em satisfiable}.
A sentence that is true in every interpretation is called {\em valid}.
These notions are extended to sets and sequents of TFF1 sentences in
a usual way.

