%First-Order Logic with Polymorphic Types
% ^^^ sounds a bit too general -- could be the title of the entire paper almost
\section{Syntax and Semantics} \label{sec_logic}

\paragraph{Type expressions.} In TFF1, we distinguish
{\em first-order types}%
\footnote{Denoted {\tt tff\_atomic\_type} in the
TPTP {\tt SyntaxBNF} document.}, assigned to individual values,
and {\em higher-order types}%
\footnote{Denoted {\tt tff\_top\_level\_type} in {\tt SyntaxBNF}.}
which specify the type signature of function and predicate symbols%
\footnote{We could also call them ``value-level types'' and
``function-level types''.}.

First-order types are constructed from {\em type variables\/}
and {\em type constructors\/} of fixed arity. A type constructor
of arity 0 is called {\em type constant}. We follow the usual
notation conventions of TPTP: type variables start with an
uppercase letter and type constructors with a lowercase letter.
There are several predefined type constants:
\verb+$iType+ (also written \verb+$i+),
\verb+$int+, \verb+$rat+, and \verb+$real+. In this paper,
we do not consider the arithmetic extensions of TPTP, and,
therefore, the types \verb+$int+, \verb+$rat+, and \verb+$real+
have no prescribed semantics%
\footnote{Should we at least guarantee infinite domains for these?}.
Here are some examples of well-formed first-order types:
\verb+A+, \verb+list(A)+, \verb+list($i)+, \verb+map($int,list(A))+.

Higher-order types have several possible forms:
\begin{itemize}
\item a first-order type --- these types are attached to
monomorphic constants;
\item the Boolean type \verb+$oType+ (also written \verb+$o+)
--- these types are attached to propositional variables and
the predefined constants \verb+$true+ and \verb+$false+;
\item {\tt ($T_1$\;*\;$\dots$\;*\;$T_n$)\;>\;$T$},
where $T_1,\dots,T_n,T$ are first-order types ---
these types are attached to monomorphic functions;
\item {\tt ($T_1$\;*\;$\dots$\;*\;$T_n$)\;>\;\$oType},
where $T_1,\dots,T_n$ are first-order types --- these types
are attached to monomorphic predicates;
\item {\tt !>\;[$A_1$:\$tType,$\dots$,%
$A_n$:\$tType]\,:\;$T$}, where $A_1,\dots,A_n$ are distinct
type variables and $T$ has one of the previous four forms ---
these types are given to polymorphic functions and predicates.
Symbol {\tt !>} denotes the type-level universal quantifier.
We require every type variable occurring in $T$ to appear
among $A_1,\dots,A_n$. The opposite is not true:
some $A_i$ may not occur in $T$.
\end{itemize}

%A type with a quantifier prefix is called {\em polytype},
%otherwise we call it {\em monotype}.
A type that does not contain type variables is called
{\em monomorphic}.
A first-order monomorphic type is called {\em sort}.
%Notice that a monotype can be a polymorphic type,
%i.e.~contain type variables.
In what follows, the term ``type'' means
first-order type unless stated otherwise.

\paragraph{Type declarations.} Type constructors, as well as
function and predicate symbols, can be declared prior to use.
For example, the following declarations introduce a type
constant {\tt bird}, a unary type constructor {\tt list},
and a binary type constructor {\tt map}:
\begin{quote}
\verb+tff(bird_t, type, bird: $tType).+
\par\medskip
\verb+tff(list_t, type, list: $tType > $tType).+
\par\medskip
\verb+tff(map_t, type, map: ($tType * $tType) > $tType).+
\end{quote}
Declaration of type constructors is not required. In TFF1,
type constructors must be fully applied, and therefore
their arity can be unambiguously determined at the first
occurrence. However, one should keep in mind that a type
expression can occur in a position of a term (see below
the examples of {\tt cons} and other polymorphic symbols).
A TFF parser should refer to the type signatures in order
to know whether it parses a term or a type.

A declaration of a function or predicate symbol gives it
a higher-order type, which we call this symbol's
{\em type signature}. For example, the following
declarations introduce a monomorphic constant {\tt pi},
a polymorphic predicate {\tt isEmpty}, and polymorphic
functions {\tt cons} and {\tt get}:
\begin{quote}
\verb+tff(pi_t, type, pi: $real).+
\par\medskip
\verb+tff(isEmpty_t, type, isEmpty: !> [A:$tType]: list(A) > $o).+
\par\medskip
\verb+tff(cons_t, type,+\\
\mbox{}\hfill
\verb+cons: !> [A:$tType]: (A * list(A)) > list(A)).+
\par\medskip
\verb+tff(get_t, type,+\\
\mbox{}\hfill
\verb+get: !> [A:$tType,B:$tType]: (map(A,B) * A) > B).+
\end{quote}
If a function or predicate symbol is used without declaration,
then default type signatures are assumed:
a function symbol gets the signature
{\tt (\$i\;*\;$\dots$\;*\;\$i)\;>\;\$i} and
a predicate symbol gets the signature
{\tt (\$i\;*\;$\dots$\;*\;\$i)\;>\;\$o}.

Any symbol (a type constructor, a function symbol, or a predicate symbol)
can be declared at most once. A symbol can be declared after being used
for the first time. In this case, the declared type signature must be
identical to the assumed one. All symbols share the same namespace; for
example, a type constructor cannot have the same name as a function symbol%
\footnote{Is this restriction present in TPTP FOF and TFF0? If not, we can
lift it for TFF1.}.

\paragraph{Function and predicate application.} In order to keep
the required type inference to the minimum, every use of a polymorphic
symbol must explicitly specify the corresponding type instance.
A function symbol with type signature
\begin{center}
{\tt !>\;[$A_1$:\$tType,$\dots$,$A_n$:\$tType]\;:\;%
($T_1$\;*\;$\dots$\;*\;$T_m$)\;>\;$T$}
\end{center}
must be applied to $n$ type arguments and $m$ term arguments
(likewise for predicate symbols). Here are some well-formed
terms and atomic formulas of TFF1:
\begin{quote}
\verb+isEmpty($i, cons($i, V, nil($i)))+
\par\medskip
\verb+get($int, list(A), M, 2)+
\end{quote}
In the first example, {\tt V} is a variable of type {\tt \$i}
and {\tt nil} is a function
symbol of type {\tt !>\;[A:\$tType]\;:\;list(A)}. In the second
example, {\tt A} is a type variable, and {\tt M} is a variable
of type {\tt map(\$int,list(A))}. Let us emphasize that type
variables can only be instantiated with first-order types.
In particular, neither \verb+$o+ nor \verb+$tType+ can occur
in type arguments of polymorphic symbols.

For systems that implement type inference, the following extension
of TFF might be useful. When a particular type argument of
a polymorphic symbol can be inferred automatically, it may be
replaced with the underscore: \verb+isEmpty(_,cons(_,V,nil(_)))+%
\footnote{Should this be part of {\tt SyntaxBNF}?}.
Notice that the type argument of {\tt nil} cannot be inferred
``locally'', from the types of other arguments (for there are none),
but it can be inferred using Hindley-Milner type inference.
The producer of a TFF problem must be aware of the type
inference algorithm implemented in the consumer, to omit
only the redundant type arguments.

\paragraph{Type variables and individual variables.}
Every variable in a TFF formula can be given a first-order type
at binding time:
\begin{verbatim}
    tff(list_not_empty, axiom,
      ! [B:bird, Bs:list(bird)]: ~ isEmpty(bird,cons(bird,B,Bs))).
\end{verbatim}
Any untyped variable gets the type \verb+$i+.
Furthermore, every type variable occurring in a TFF formula
(in a type argument or in a type of a bound variable)
must be also bound:
\begin{verbatim}
    tff(get_set, axiom,
      ! [A:$tType, B:$tType, M:map(A,B), I:A, V:B]:
          get(A,B,set(A,B,M,I,V),I) = V).
\end{verbatim}
Notice that one can put type variables and ordinary variables
under the same quantifier. The order of variables is important:
if the type of an ordinary variable contains a type variable,
the latter must appear before the former%
\footnote{We can permit omitting the {\tt\$tType} annotations,
too, but should we? If an untyped variable can turn to be
a type variable or an {\tt\$i}-variable, then we must look
into the formula to know which it is.}.
Type variables can be bound both by universal and existential
quantifiers.
We allow such bindings to occur under quantifiers over ordinary
variables as well as under equivalence, negation, et cetera ---
basically, wherever an ordinary variable can be bound.

Another way to introduce a variable is by a let-statement.
The initial revision of the TFF format allowed to bind a variable
to a term as well as to a formula (a variable thus bound has
``type'' \verb+$o+ and can only appear in a position of a formula)%
\footnote{Should we elaborate on the syntax of let?
It was already in TFF0, but it was not described in
the article on TFF0. The same about if/ite: should
we talk about them, though they are completely
orthogonal to polymorphism and types?}.
%In the former case,
%the syntax of binding is {\it variable}~{\tt :-}~{\it term\/} and
%the type of the variable is the type of the term. In the latter case,
%the syntax of binding is {\it variable}~{\tt :=}~{\it formula\/} and
%a variable thus bound has the ``type'' \verb+$o+ and
%can only appear in a position of a formula (notice that
%one cannot quantify over a variable of type \verb+$o+).
In TFF1, we additionally admit binding a type variable
to a first-order type%
%using the syntax {\it variable}~{\tt :>}~{\it type}%
\footnote{Since any first-order type is a well-formed TFF term,
we could reuse the existing syntax for these bindings.
But then suppose that {\tt foo} is undeclared and
we bind {\tt A} to it: {\tt A} {\tt :-} {\tt foo}.
Until {\tt A} is used
(as a type or as a value), we cannot know what it is.}.
For example,
the axiom \verb+list_not_empty+ above could be written as
follows:
\begin{verbatim}
    tff(list_not_empty, axiom,
      := [T :> bird]:
          ! [B:T, Bs:list(T)]: ~ isEmpty(T,cons(T,B,Bs))).
\end{verbatim}
One can put a mixed list of bindings in a let-statement;
in such lists each subsequent binding can refer
to variables introduced by preceding ones%
\footnote{Is this true in TFF0? I didn't find any written
specification of multi-variable let.}.

The let-bindings can be eliminated from TFF formulas by simple
substitution (with renaming of bound variables where necessary
to avoid capture). For the sake of brevity, we do not consider
them in the following sections.

\paragraph{Notation.} From now on, we use standard
mathematical notation to write types, terms, and formulas.
We denote type variables with small Greek letters
$\alpha$, $\beta$, $\gamma$, type constructors
with letters $I$, $K$, $L$, and first-order
types with letters $T$ and $S$. Ordinary variables
are denoted $u$, $v$, $w$, $x$, $y$, $z$; function
symbols are denoted $f$, $g$, $h$; predicate symbols
are denoted $p$ and $q$. The letters $t$ and $s$ denote
terms and the letters $F$, $G$, $H$ denote formulas.
Sometimes, we write the names of type constructors,
function and predicate symbols using a fixed-width
font: {\tt list}, {\tt map}, {\tt cons}, {\tt set}
etc.

We use symbols ${\times}$, ${\to}$, and ${\ALL}$
to write higher-order types. We treat equality ($\approx$),
negation ($\lnot$), conjunction ($\land$), and the universal
quantifier ($\forall$) as logical symbols and we treat
disjunction ($\lor$), implication ($\limp$), equivalence
($\lequ$), disequality ($\not\approx$), and the existential
quantifier ($\exists$) as abbreviations.

Given a formula $F$, the set of type variables
freely occurring in $F$ (in type arguments of
polymorphic symbols or in types of bound variables)
is denoted $\FVT(F)$. The set of free variables of $F$
is denoted $\FV(F)$. We call $F$ {\em closed\/}
whenever both $\FVT(F)$ and $\FV(F)$ are empty.

A {\em type substitution\/} is a mapping of type variables
to first-order types. A {\em monomorphic\/} type substitution
maps every type variable either to itself or to a sort.
%
A type $T$ is said to {\em match\/} another
type $T'$ whenever there is a type substitution
that instantiates $T$ to $T'$.
We use Greek letters $\tau$, $\theta$, and $\pi$ for type
substitutions.
Ordinary substitutions that map variables to terms
are denoted with letters $\sigma$ and $\delta$.
The symbol $\circ$ denotes the composition
of two (type) substitutions:
$x(\sigma \circ \delta) \eqdef x\sigma\delta$.

