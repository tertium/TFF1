%First-Order Logic with Polymorphic Types
% ^^^ sounds a bit too general -- could be the title of the entire paper almost
\section{Syntax and Semantics} \label{sec_logic}

\paragraph{Type expressions.}
We distinguish {\em first-order types}, assigned
to individual values, and {\em higher-order types} which
specify the type signature of function and predicate symbols%
\footnote{We could also call them ``value-level types'' and
``function-level types''.}.
%
First-order types are built from {\em type variables\/}
and {\em type constructors\/} of fixed arity. A type constructor
of arity 0 is called {\em type constant}. We follow the usual
notation conventions of TPTP: type variables start with an
uppercase letter and type constructors with a lowercase letter.
There are several predefined type constants:
\verb+$iType+ (also written \verb+$i+),
\verb+$int+, \verb+$rat+, and \verb+$real+. In this paper,
we do not consider the arithmetic extensions of TPTP, and,
therefore, the types \verb+$int+, \verb+$rat+, and \verb+$real+
have no prescribed semantics%
\footnote{Should we at least guarantee infinite domains for those?}.
Here are some examples of well-formed first-order types:
\verb+A+, \verb+list(A)+, \verb+list($i)+, \verb+map($int,list(A))+.

Higher-order types have several possible forms:
\begin{itemize}
\item a first-order type --- these types are attached to
monomorphic constants;
\item the Boolean type \verb+$oType+ (also written \verb+$o+)
--- these types are attached to propositional variables and
the predefined constants \verb+$true+ and \verb+$false+;
\item {\tt ($T_1$\;*\;${\dots}$\;*\;$T_n$)\;>\;$T$},
where $T_1,\dots,T_n,T$ are first-order types ---
these types are attached to monomorphic functions;
\item {\tt ($T_1$\;*\;${\dots}$\;*\;$T_n$)\;>\;\$oType},
where $T_1,\dots,T_n$ are first-order types --- these types
are attached to monomorphic predicates;
\item {\tt !>\;[$A_1$:\$tType,${\dots}$,%
$A_n$:\$tType]\,:\;$T$}, where $A_1,\dots,A_n$ are distinct
type variables and $T$ has one of the previous four forms ---
these types are given to polymorphic functions and predicates.
Symbol {\tt !>} denotes the type-level universal quantifier.
We require every type variable occurring in $T$ to appear
among $A_1,\dots,A_n$.
%The opposite is not true: some $A_i$ may not occur in $T$.
\end{itemize}

%A type with a quantifier prefix is called {\em polytype},
%otherwise we call it {\em monotype}.
A type that does not contain type variables is called
{\em monomorphic}.
%A first-order monomorphic type is called {\em sort}.
%Notice that a monotype can be a polymorphic type,
%i.e.~contain type variables.
In what follows, the term ``type'' means
first-order type unless stated otherwise.

\paragraph{Type declarations.} Type constructors, as well as
function and predicate symbols, can be declared prior to use.
For example, the following declarations introduce a type
constant {\tt bird}, a unary type constructor {\tt list},
and a binary type constructor {\tt map}:
\begin{quote}
\verb+tff(bird_t, type, bird: $tType).+
\par\medskip
\verb+tff(list_t, type, list: $tType > $tType).+
\par\medskip
\verb+tff(map_t, type, map: ($tType * $tType) > $tType).+
\end{quote}
Declaration of type constructors is not required. In TFF1,
type constructors must be fully applied, and therefore
their arity can be unambiguously determined at the first
occurrence. However, one should keep in mind that a type
expression can occur in a position of a term (see below
the examples of {\tt cons} and other polymorphic symbols).
A TFF parser should refer to the type signatures of function
and predicate symbols in order to know whether it parses
a term or a type.

A declaration of a function or predicate symbol gives it
a higher-order type, which we call this symbol's
{\em type signature}. For example, the following
declarations introduce a monomorphic constant {\tt pi},
a polymorphic predicate {\tt isEmpty}, and polymorphic
functions {\tt cons} and {\tt get}:
\begin{quote}
\verb+tff(pi_t, type, pi: $real).+
\par\medskip
\verb+tff(isEmpty_t, type, isEmpty: !> [A:$tType]: list(A) > $o).+
\par\medskip
\verb+tff(cons_t, type,+\\
\mbox{}\hfill
\verb+cons: !> [A:$tType]: (A * list(A)) > list(A)).+
\par\medskip
\verb+tff(get_t, type,+\\
\mbox{}\hfill
\verb+get: !> [A:$tType,B:$tType]: (map(A,B) * A) > B).+
\end{quote}
If a function or predicate symbol is used without declaration,
then default type signatures are assumed:
a function symbol gets the signature
{\tt (\$i\;*\;${\dots}$\;*\;\$i)\;>\;\$i} and
a predicate symbol gets the signature
{\tt (\$i\;*\;${\dots}$\;*\;\$i)\;>\;\$o}.

Any symbol (a type constructor, a function symbol, or a predicate symbol)
can be declared at most once. A symbol can be declared after being used
for the first time. In this case, the declared type signature must be
identical to the assumed one. All symbols share the same namespace; for
example, a type constructor cannot have the same name as a function symbol%
\footnote{Is this restriction present in TPTP FOF and TFF0? If not, we can
lift it for TFF1.}.

\paragraph{Function and predicate application.} In order to keep
the required type inference to the minimum, every use of a polymorphic
symbol must explicitly specify the corresponding type instance.
A function symbol with a type signature
\begin{center}
{\tt !>\;[$A_1$:\$tType,${\dots}$,$A_n$:\$tType]\;:\;%
($T_1$\;*\;${\dots}$\;*\;$T_m$)\;>\;$T$}
\end{center}
must be applied to $n$ type arguments and $m$ term arguments
(likewise for predicate symbols). Here are some well-formed
terms and atomic formulas of TFF1:
\begin{quote}
\verb+isEmpty($i, cons($i, V, nil($i)))+
\par\medskip
\verb+get($int, list(A), M, 2)+
\end{quote}
In the first example, {\tt V} is a variable of type {\tt \$i}
and {\tt nil} is a function
symbol of type {\tt !>\;[A:\$tType]\;:\;list(A)}. In the second
example, {\tt A} is a type variable, and {\tt M} is a variable
of type {\tt map(\$int,list(A))}. Let us emphasize that type
variables can only be instantiated with first-order types.
In particular, neither \verb+$o+ nor \verb+$tType+ can occur
in type arguments of polymorphic symbols.

For systems that implement type inference, the following extension
of TFF might be useful. When a particular type argument of
a polymorphic symbol can be inferred automatically, it may be
replaced with the underscore: \verb+isEmpty(_,cons(_,V,nil(_)))+%
\footnote{Should this be part of {\tt SyntaxBNF}?}.
Notice that the type argument of {\tt nil} cannot be inferred
``locally'', from the types of other arguments (for there are none),
but it can be inferred using Hindley-Milner type inference.
The producer of a TFF problem must be aware of the type
inference algorithm implemented in the consumer, to omit
only the redundant type arguments.

\paragraph{Type variables and individual variables.}
Every variable in a TFF formula can be given a first-order type
at binding time:
\begin{verbatim}
    tff(list_not_empty, axiom,
      ! [B:bird, Bs:list(bird)]: ~ isEmpty(bird,cons(bird,B,Bs))).
\end{verbatim}
An untyped variable gets the type \verb+$i+.
Furthermore, every type variable occurring in a TFF formula
(in a type argument or in a type of a bound variable)
must be also bound:
\begin{verbatim}
    tff(get_set, axiom,
      ! [A:$tType, B:$tType, M:map(A,B), I:A, V:B]:
          get(A,B,set(A,B,M,I,V),I) = V).
\end{verbatim}
Notice that one can put type variables and ordinary variables
under the same quantifier. The order of variables is important:
if the type of an ordinary variable contains a type variable,
the latter must appear before the former%
\footnote{We can permit omitting the {\tt\$tType} annotations,
too, but should we? If an untyped variable can turn to be
a type variable or an {\tt\$i}-variable, then we must look
into the formula to know which it is.}.
Type variables can be bound both by universal and existential
quantifiers.
We allow such bindings to occur under quantifiers over ordinary
variables as well as under equivalence, negation, et cetera ---
basically, wherever an ordinary variable can be bound%
\footnote{Allowing quantifiers over type variables in the scope
of the quantifiers over ordinary variables is problematic.
Type skolemization becomes impossible, as it requires type
constructors to accept value arguments (that is, brings in
dependent types). There seems to be no easy way to translate
the offending type quantifiers out, short of encoding all
types as terms.}.

Another way to introduce a variable is by a let-statement.
The initial revision of the TFF format allowed to bind a variable
to a term as well as to a formula (a variable thus bound has
``type'' \verb+$o+ and can only appear in a position of a formula)%
\footnote{Should we elaborate on the syntax of let?
It was already in TFF0, but it was not described in
the article on TFF0. The same about if/ite: should
we talk about them, though they are completely
orthogonal to polymorphism and types?}.
%In the former case,
%the syntax of binding is {\it variable}~{\tt :-}~{\it term\/} and
%the type of the variable is the type of the term. In the latter case,
%the syntax of binding is {\it variable}~{\tt :=}~{\it formula\/} and
%a variable thus bound has the ``type'' \verb+$o+ and
%can only appear in a position of a formula (notice that
%one cannot quantify over a variable of type \verb+$o+).
In TFF1, we additionally admit binding a type variable
to a first-order type%
%using the syntax {\it variable}~{\tt :>}~{\it type}%
\footnote{Since any first-order type is a well-formed TFF term,
we could reuse the existing syntax for these bindings.
But then suppose that {\tt foo} is undeclared and
we bind {\tt A} to it: {\tt A} {\tt :-} {\tt foo}.
Until {\tt A} is used
(as a type or as a value), we cannot know what it is.}.
For example,
the axiom \verb+list_not_empty+ above could be written as
follows:
\begin{verbatim}
    tff(list_not_empty, axiom,
      := [T :> bird]:
          ! [B:T, Bs:list(T)]: ~ isEmpty(T,cons(T,B,Bs))).
\end{verbatim}
One can put a mixed list of bindings in a let-statement;
in such lists each subsequent binding can refer
to the variables introduced by preceding ones%
\footnote{Is this true in TFF0? I didn't find any written
specification of multi-variable let.}.

The let-bindings can be eliminated from TFF formulas by simple
substitution (with renaming of bound variables where necessary
to avoid capture). For the sake of brevity, we do not consider
them in the following sections.

\paragraph{Notation.} From now on, we use standard
mathematical notation to write types, terms, and formulas.
We denote type variables with small Greek letters
$\alpha$, $\beta$, $\gamma$, type constructors
with letters $I$, $K$, $L$, and first-order
types with letters $T$ and $S$. Ordinary variables
are denoted $u$, $v$, $w$, $x$, $y$, $z$; function
symbols are denoted $f$, $g$, $h$; predicate symbols
are denoted $p$ and $q$. The letters $t$ and $s$ denote
terms and the letters $F$, $G$, $H$ denote formulas.
Sometimes, we write the names of type constructors,
function and predicate symbols using a fixed-width
font: {\tt list}, {\tt map}, {\tt cons}, {\tt set},
etc.

We use symbols ${\times}$, ${\to}$, and ${\ALL}$
%\footnote{We can also use ${\prod}$, but should we,
%given that there are no dependent types in TFF1?}
to write higher-order types. The Greek letter $\omicron$ denotes
the Boolean type {\tt \$o}. We treat equality ($\approx$),
negation ($\lnot$), conjunction ($\land$), and the universal
quantifier ($\forall$) as logical symbols and we treat
disjunction ($\lor$), implication ($\limp$), equivalence
($\lequ$), disequality ($\not\approx$), and the existential
quantifier ($\exists$) as abbreviations.
%The symbols $\top$ and $\bot$ stand for ``true'' and ``false'',
%respectively.

The set of type variables freely occurring in a formula $F$
(in the type arguments of polymorphic symbols or
in the types of bound variables) is denoted $\FVT(F)$.
The set of free ordinary variables of $F$
is denoted $\FV(F)$. We call $F$ {\em closed\/}
whenever both $\FVT(F)$ and $\FV(F)$ are empty.

A {\em type substitution\/} is a mapping of type variables
to first-order types. A {\em monomorphic\/} type substitution
maps every type variable either to itself or to a monomorphic type.
%
A type $T$ is said to {\em match\/} another type $T'$ whenever
there is a type substitution that instantiates $T$ to $T'$.
We use Greek letters $\tau$ and $\rho$ for type substitutions.
%
Ordinary substitutions that map variables to terms
are denoted with letters $\sigma$ and $\delta$.
The symbol $\circ$ denotes the composition
of two (type) substitutions:
$x(\sigma \circ \delta) \eqdef x\sigma\delta$.

\paragraph{Type checking.}
Let $\gamma$ be a {\em type context}, a function that maps
every variable symbol to a type.
A type judgement $\gamma \,\vdash t \ty T$ means that term $t$
is {\em well-typed\/} and has type $T$ in context $\gamma$.
A type judgement $\gamma \,\vdash F \ty \omicron$ means that formula $F$
is {\em well-typed\/} in $\gamma$.
We write $f \,\ty\, \forall \alpha_1\dots\alpha_n \,.\,
T_1 \times \dots \times T_m \to T$ and
$p \,\ty\, \forall \alpha_1\dots\alpha_n \,.\,
T_1 \times \dots \times T_m \to \omicron$ to specify
type signatures of function and predicate symbols;
notice that $n$ and $m$ can both be zero.

The typing rules of TFF are given in Figure~\ref{fig:typing}.
We write $\gamma[v \mapsto T]$ to denote a type context that maps
variable $v$ to type $T$ and every other variable $u$ to $\gamma(u)$.
In the last rule, $\alpha'$ is an arbitrary type variable that
occurs neither in $F$ nor in the values of $\gamma$.
The renaming is necessary to reject formulas like
$\forall\alpha\forall u\ty\alpha\forall\alpha\forall v\ty\alpha \,.\,
u \approx v$, where the types of $u$ and $v$ are actually different.
In order to simplify our subsequent definitions, we assume from now on
that no type variable can be both free and bound in the same formula;
we call this the {\em no-clash assumption}.
%Consequently, nested quantifiers on the same type
%variable are not allowed, either.
Then we can do without explicit renaming of type variables,
and the last typing rule is simply
$\frac{\gamma\, \,\vdash\, F \ty \omicron}{
\gamma\, \,\vdash\, \forall \alpha \,.\, F \,\ty\, \omicron}$.

\begin{figure}
\begin{center}
\begin{tabular}{c@{\qquad\qquad}c}
\multicolumn{2}{c}{$\displaystyle
\frac{}{\gamma\, \:\vdash\: v \ty \gamma\,(v)}$} \\[4ex]
\multicolumn{2}{c}{$\displaystyle
\frac{f \,\ty\, \forall \alpha_1\dots\alpha_n \,.\,
    T_1 \times \dots \times T_m \to T
\qquad
\gamma\, \,\vdash\, t_1 \ty T_1\tau
\quad\cdots\quad
\gamma\, \,\vdash\, t_m \ty T_m\tau
}{\gamma\, \:\vdash\:
f(\alpha_1\tau,\dots,\alpha_n\tau,t_1,\dots,t_m) \,\ty\, T\tau}
$} \\[4ex]
\multicolumn{2}{c}{$\displaystyle
\frac{p \,\ty\, \forall \alpha_1\dots\alpha_n \,.\,
    T_1 \times \dots \times T_m \to \omicron
\qquad
\gamma\, \,\vdash\, t_1 \ty T_1\tau
\quad\cdots\quad
\gamma\, \,\vdash\, t_m \ty T_m\tau
}{\gamma\, \:\vdash\:
p(\alpha_1\tau,\dots,\alpha_n\tau,t_1,\dots,t_m) \,\ty\, \omicron}
$} \\[4ex]
$\qquad\displaystyle
\frac{\gamma\, \,\vdash\, t_1 \ty T \qquad \gamma\, \,\vdash\, t_2 \ty T}{
\gamma\, \:\vdash\: t_1 \approx t_2 \,\ty\, \omicron}$ &
$\displaystyle
\frac{\gamma\, \,\vdash\, F \ty \omicron \qquad
\gamma\, \,\vdash\, G \ty \omicron}{
\gamma\, \,\vdash\, F \land G \,\ty\, \omicron}\qquad$ \\[4ex]
\multicolumn{2}{c}{
$\displaystyle
\frac{\gamma\, \,\vdash\, F \ty \omicron}{
\gamma\, \,\vdash\, \lnot F \,\ty\, \omicron}\qquad\qquad
\frac{\gamma[v \mapsto T] \,\vdash\, F \ty \omicron}{
\gamma\, \,\vdash\, \forall v \ty T .\, F \,\ty\, \omicron}\qquad\qquad
\frac{\gamma\, \,\vdash\, F[\alpha'/\alpha] \ty \omicron}{
\gamma\, \,\vdash\, \forall \alpha \,.\, F \,\ty\, \omicron}$}
\end{tabular}
\end{center}
\caption{Typing rules of TFF}
\label{fig:typing}
\end{figure}

A closed TFF formula $H$ is {\em well-typed\/} if and only if
the judgement $\gamma\, \vdash H \ty \omicron$ is derivable
for any $\gamma$.
Obviously, if a closed formula is
well-typed in one type context, it is well-typed in any other one;
in what follows, we omit $\gamma$ and simply write
${} \vdash H \ty \omicron$.
Closed well-typed formulas are called {\em sentences}.

\paragraph{Interpretation.}
An interpretation $\cI$ for a given set of type constructors,
function symbols, and predicate symbols is constructed as follows.
We start with a non-empty collection $\sorts$ of non-empty sets,
which we call {\em domains}. The union, not necessarily disjoint,
of all domains is called {\em universe\/} and denoted $\univ$.

A type constructor $K$ of arity $n$ is interpreted as a function
$K^{\cI} : \sorts^n \to \sorts$.
Let $\theta$ be a {\em type valuation}, a function that maps every
type variable to a domain. We evaluate first-order types according
to the following equations:
\begin{align*}
\evalT{\alpha} &\eqdef \theta(\alpha) &
\evalT{K(T_1,\dots,T_n)} &\eqdef K^{\cI}(\evalT{T_1},\dots,\evalT{T_n})
\end{align*}
Since type evaluation depends only on the values of $\theta$
on the type variables occurring in a type, we write $\evalG{S}$
to denote the domain of a monomorphic type $S$. We also write
$\evalG{T}_{[\alpha_1\,\mapsto\,D_1,\dots,\alpha_n\,\mapsto\,D_n]}$
to evaluate a type whose free type variables
belong to $\alpha_1,\dots,\alpha_n$.

A predicate symbol $p$ of signature
$\forall \alpha_1\dots\alpha_n \,.\, T_1 \times \dots \times T_m
\to \omicron$ is interpreted as a relation
$p^{\cI} \subseteq \sorts^n \times \univ^m$.
A function symbol $f$ of signature
$\forall \alpha_1\dots\alpha_n \,.\, T_1 \times \dots \times T_m \to T$
is interpreted as a function
$f^{\cI}$ on $\sorts^n \times \univ^m$ that
maps any $n$ domains $D_1,\dots,D_n$ and
any $m$ elements of the universe
to an element of
$\evalG{T}_{[\alpha_1\,\mapsto\,D_1,\dots,\alpha_n\,\mapsto\,D_n]}$.
%Recall that every type variable occurring in a type signature
%must be bound, and therefore every type variable in $T$ belongs
%to $\{ \alpha_1,\dots,\alpha_n \}$.

Let $\xi$ be a {\em variable valuation}, a function that assigns
to every variable an element of $\univ$. We evaluate TFF terms
and formulas according to the following equations:
\begin{align*}
\eval{u} &\eqdef \xi(u) &
\eval{f(\bar{S},\bar{t})} &\eqdef f^\cI(\evalT{\bar{S}},\eval{\bar{t}}) \\
\eval{t_1 \approx t_2} &\eqdef (\eval{t_1} = \eval{t_2}) &
\eval{p(\bar{S},\bar{t})} &\eqdef p^\cI(\evalT{\bar{S}},\eval{\bar{t}}) \\
\eval{\lnot F} &\eqdef \lnot\, \eval{F} &
\eval{F \land G} &\eqdef \eval{F} \land\, \eval{G} \\
\eval{\forall u \ty T .\, F} &\eqdef \forall {a \in \evalT{T}} \,.\,
\evalG{F}_{\theta,\xi[u\,\mapsto\,a]} &
\eval{\forall \alpha \,.\, F} &\eqdef \forall {D \in \sorts} \,.\,
\evalG{F}_{\theta[\alpha\,\mapsto\,D],\xi} % \\
%\eval{\forall u \ty T .\, F} &\eqdef \!\!\!\!
%\bigwedge_{a \in \evalT{T}} \!
%\evalG{F}_{\theta,\xi[u\,\mapsto\,a]} &
%\eval{\forall \alpha \,.\, F} &\eqdef
%\bigwedge_{D \in \sorts}\;
%\evalG{F}_{\theta[\alpha\,\mapsto\,D],\xi}
\end{align*}
Here, $\bar{S}$ and $\bar{t}$ are sequences of types and terms, respectively.
The expression $\xi[u \mapsto a]$ stands for the function that
maps variable $u$ to $a$ and every other variable $v$ to $\xi(v)$.
Likewise, $\theta[\alpha \mapsto D]$ is the function that maps
type variable $\alpha$ to domain $D$ and every other type
variable $\beta$ to $\theta(\beta)$. In what follows,
we omit the irrelevant subscripts and write $\evalG{F}$
to denote the evaluation of a closed formula.

We say that a sentence $F$ is {\em true} in an interpretation $\cI$
and denote it by $\cI \models F$ if and only if $\evalG{F}$ is true.
The interpretation $\cI$ is called then a {\em model\/} of $F$.
A sentence that has a model is called {\em satisfiable}.
A sentence that is true in every interpretation is called {\em valid}.
These notions are extended to sets and sequents of TFF sentences in
a usual way.

