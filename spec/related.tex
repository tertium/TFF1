\section{Related Work}
\label{sec_related}

\ourparagraph{Formalisms.}
The TPTP family of formats is well established in the automated reasoning
community. As part of the MPTP project \cite{urban-2006}, Urban designed private
extensions of the TPTP FOF syntax with dependent types to
accommodate Mizar, as well as translations;
these could form the basis of a future TFF2 format. The full THF syntax \cite{sutcliffe-benzmueller-2010},
which is not yet finalized or implemented,
also supports dependent types.

        %most reasoning tools out there are first-order, and the higher-order syntax is
        %sufficiently unwieldy that it's unrealistic to expect apps to support it;
        %furthermore, the form of polymorphism offered there is much more general than
        %what we expect to need in the first-order setting.

For interactive theorem provers, polymorphism is the norm rather
than the exception. HOL systems
\cite{gordon-melham-1993,harrison-1996,nipkow-et-al-2002} provide
%simple types with %top-level,
ML-style (rank-1) polymorphism, while Coq
\cite{bertot-casteran-2004} supports dependent types and higher-rank
polymorphism.
The SMT solver Alt-Ergo \cite{bobot-et-al-2008} is perhaps the only automatic
prover that supports polymorphism natively.
%, with a concrete syntax very close to ML.

The intermediate verification language and tool Boogie 2 \cite{leino-ruemmer-2010}
supports a restricted form of higher-rank polymorphism (due to its polymorphic maps),
and its cousin Why3 \cite{bobot-et-al-2011}
provides rank-1 polymorphism. Both provide TPTP and SMT-LIB backends.

\ourparagraph{Encodings.}
Early descriptions of type encodings are due to Enderton
\cite[\S4.3]{enderton-1972}, Stickel \cite[p.~99]{stickel-1986}, and Wick and
McCune \cite[\S4]{wick-mccune-1989}. TFF1 type arguments are reminiscent of
System~F; a FOF-based encoding that exploits them is described by Meng and
Paulson \cite{meng-paulson-2008-trans}, who also present a translation of
axiomatic type classes.

Considerable progress has been made lately toward sound, complete, and efficient
encodings of polymorphic logics in untyped or monomorphic logics. Leino and
R\"ummer \cite{leino-ruemmer-2010} present a translation of higher-rank
polymorphism, including explicit quantifiers over types, into the many-sorted
SMT-LIB syntax, while preserving interpreted types. They also show how to
exploit SMT triggers to prevent unsound variable instantiations in a
translation based on type arguments. Bobot and Paskevich
\cite{bobot-paskevich-2011} extend earlier work by Couchot and Lescuyer
\cite{couchot-lescuyer-2007} to encode polymorphism while preserving
arbitrary monomorphic types (e.g., array types).
Blanchette et
al.\ \cite{blanchette-et-al-2012-mono}, building on work by Claessen et al.\
\cite{claessen-et-al-2011}, present a %particularly
lightweight encoding of
polymorphic types that exploits type monotonicity. All of these translations
assume %preliminary
elimination of \theghost{} type variables
(Section~\ref{ssec:ghost}); the last two also assume type skolemization
(Section~\ref{ssec:skol}).

%An easy approach to pass TFF1 problems can be passed to TFF0
%reasoning tools is to monomorphize the problem first---that is, to heuristically
%instantiate all type variables with appropriate
%ground types. Monomorphization is incomplete and often overlooked
%or derided in the literature \cite[p.\ 3]{couchot-lescuyer-2007}, but it was
%applied with much success in both Sledgehammer
%\cite[\S6]{blanchette-et-al-2012-mono} and Why3.
%% @ANDREI: Reference for Why3's monomorphization (if one exists)?
