\section{Related Work}
\label{sec_related}

\ourparagraph{Formalisms.}
The TPTP family of formats is well established in the automated reasoning
community. As part of the MPTP project \cite{urban-2006}, Urban designed private
extensions of the TPTP FOF syntax with dependent polymorphic types, and
translation from these, but there was no attempt to standardize these; TFF2 is
expected to subsume this work. Also related to TFF1 is the full THF syntax
\cite{sutcliffe-benzmueller-2010}, which is not yet finalized or implemented.
Like Urban's extensions, full THF supports dependent types.
        %most reasoning tools out there are first-order, and the higher-order syntax is
        %sufficiently unwieldy that it's unrealistic to expect apps to support it;
        %furthermore, the form of polymorphism offered there is much more general than
        %what we expect to need in the first-order setting.

For SMT solvers, the SMT-LIB format \cite{barrett-et-al-2010}
specifies a classical many-sorted logic with equality and interpreted
arithmetic, much in the style of TFF0 but with overloading (ad hoc
polymorphism). The SMT solver Alt-Ergo \cite{bobot-et-al-2008} defines its own
polymorphic format with a syntax very close to ML.

In the world of interactive theorem proving, polymorphism is the norm rather
than the exception. HOL systems \cite{gordon-melham-1993} provide simple types
with top-level, ML-style (rank-1) polymorphism, while Coq
\cite{bertot-casteran-2004} supports dependent types and higher-rank
polymorphism.

The intermediate verification language Boogie 2 \cite{leino-ruemmer-2010}
supports higher-rank polymorphism (due to its polymorphic maps),
and its cousin Why3 \cite{bobot-et-al-2011}
supports rank-1 polymorphism.% Both provide TPTP and SMT-LIB backends.

\ourparagraph{Encodings.}
Early descriptions of type encodings are due to Enderton
\cite[\S4.3]{enderton-1972}, Stickel \cite[p.~99]{stickel-1986}, and Wick and
McCune \cite[\S4]{wick-mccune-1989}. TFF1 type arguments are reminiscent of
System~F; a FOF-based encoding that exploits them is described by Meng and
Paulson \cite{meng-paulson-2008-trans}, who also present a translation of
axiomatic type classes.

Considerable progress has been made lately toward sound, complete, and efficient
encodings of polymorphic logics in untyped or monomorphic logics. Leino and
R\"ummer \cite{leino-ruemmer-2010} present a translation of higher-rank
polymorphism, including explicit quantifiers over types, into the many-sorted
SMT-LIB syntax, while preserving interpreted types. They also show how to
exploit SMT triggers to prevent unsound variable instantiations in a
translation based on type arguments. Bobot and Paskevich
\cite{bobot-paskevich-2011} expand on earlier work by Couchot and Lescuyer
\cite{couchot-lescuyer-2007} to encode polymorphism while preserving selected
monomorphic types (e.g., for arithmetic and array types).
Blanchette et
al.\ \cite{blanchette-et-al-2012-mono}, building on work by Claessen et al.\
\cite{claessen-et-al-2011}, present a particularly lightweight encoding of
polymorphic types that exploits type monotonicity. All of these translations
assume preliminary elimination of ghost type arguments
(Section~\ref{ssec:ghost}); the last two also assumes type skolemization
(Section~\ref{ssec:skol}).

An easy approach to pass TFF1 problems can be passed to TFF0
reasoning tools is to monomorphize the problem first---that is, to heuristically
instantiate all type variables with appropriate
ground types. Monomorphization is incomplete and often overlooked
or derided in the literature \cite[p.\ 3]{couchot-lescuyer-2007}, but it was
applied with much success in Sledgehammer \cite[\S6]{blanchette-et-al-2012-mono}
and Why3.
%% @ANDREI: Reference for Why3?
